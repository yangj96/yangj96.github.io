<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Jingy&#39;s Blog">
<meta property="og:url" content="https://yangj96.github.io/index.html">
<meta property="og:site_name" content="Jingy&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jingy&#39;s Blog">






  <link rel="canonical" href="https://yangj96.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Jingy's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jingy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/yangj96" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/06/09/prob/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/09/prob/" class="post-title-link" itemprop="url">概率类面试题目总计</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-09 11:40:54" itemprop="dateCreated datePublished" datetime="2020-06-09T11:40:54+08:00">2020-06-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-30 11:10:48" itemprop="dateModified" datetime="2020-06-30T11:10:48+08:00">2020-06-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">134</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最后问了一个概率题，一副扑克牌54张，随意洗牌，分为两份，每份有两个2的概率。</p>
<p>概率题：13个人生日都不是同一天的概率，要求给出表达式和最终结果（不用计算器估算）</p>
<p>现在我有抛一枚硬币，正面朝上的概率是p,反面是1-p。那么第k次抛的时候出现第一次正面的概率是多少?</p>
<p><img src="/Users/jingy/Library/Application Support/typora-user-images/image-20200609114558736.png" alt="image-20200609114558736"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/06/08/deep-learning-interview/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/08/deep-learning-interview/" class="post-title-link" itemprop="url">深度学习面试问题总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-08 21:14:22" itemprop="dateCreated datePublished" datetime="2020-06-08T21:14:22+08:00">2020-06-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-21 10:46:16" itemprop="dateModified" datetime="2020-07-21T10:46:16+08:00">2020-07-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">3k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">3 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><h5 id="过拟合-欠拟合"><a href="#过拟合-欠拟合" class="headerlink" title="过拟合/欠拟合"></a>过拟合/欠拟合</h5><p>过拟合的表现：</p>
<p>看loss</p>
<p>train loss 不断下降，test loss不断下降，说明网络仍在学习;</p>
<p>train loss 不断下降，test loss趋于不变，说明网络过拟合;</p>
<p>train loss 趋于不变，test loss不断下降，说明数据集100%有问题;</p>
<p>train loss 趋于不变，test loss趋于不变，说明学习遇到瓶颈，需要减小学习率或批量数目;</p>
<p>train loss 不断上升，test loss不断上升，说明网络结构设计不当，训练超参数设置不当，数据集经过清洗等问题</p>
<p>过拟合的解决方法：</p>
<p>降低模型复杂度，例如神经网络：减少网络层、神经元个数决策树；降低树的深度、剪枝</p>
<p>权值约束，增加正则化项，L1稀疏，L2权重衰减</p>
<p>Batch Normalization</p>
<p>landscape平滑，x归一化到0附近，更容易被激活</p>
<p>early stop 避免权重一直更新</p>
<p>dropout（dropout会导致输出结果随机，因此在测试时，根据概率计算的平均结果我们需要将激活函数乘以dropping概率，通常为0.5 进行伸缩作为最终结果，或在训练时的dropout mask步骤直接除以dropping概率）</p>
<p>使用ReLU激活函数替代Sigmoid，ReLU具备稀疏激活性，负半区梯度变为0</p>
<p>数据增强</p>
<p>集成学习</p>
<h5 id="梯度爆炸的解决方法"><a href="#梯度爆炸的解决方法" class="headerlink" title="梯度爆炸的解决方法"></a>梯度爆炸的解决方法</h5><p>（w&gt;1不断累积）</p>
<p>梯度裁剪 clip gradient</p>
<p>模型结构 resnet、lstm遗忘门</p>
<p>BN 使x的期望在0附近</p>
<p>参数的初始化</p>
<p>针对ReLU激活函数的神经元，其权重初始化通常使用随机数并使用$sqrt(2.0/n)$来平衡方差[^weightInit]，而bias通常直接初始化为零</p>
<h5 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h5><p>（w&lt;1不断累积）</p>
<p>激活函数使用ReLU替代Sigmoid，ReLU的梯度x&gt;0始终为1，但x&lt;0时梯度为0神经元死亡，一定程度上可以调小学习率解决</p>
<h5 id="ReLU取代Sigmoid的优点"><a href="#ReLU取代Sigmoid的优点" class="headerlink" title="ReLU取代Sigmoid的优点"></a>ReLU取代Sigmoid的优点</h5><p>避免梯度弥散</p>
<p><code>ReLU</code> 的求导不涉及浮点运算，加速计算</p>
<p>负半区的输出为 0，稀疏激活，减少过拟合</p>
<h5 id="Maxout"><a href="#Maxout" class="headerlink" title="Maxout"></a>Maxout</h5><p>$f(x)=max(w_1^Tx+b_1, w_2^Tx + b_2)$<br>ReLU和Leaky ReLU都是这一函数的特例，例如ReLU对应w1,b1=0。</p>
<h5 id="正则化范数"><a href="#正则化范数" class="headerlink" title="正则化范数"></a>正则化范数</h5><p>L0 非0个数</p>
<p>L1 </p>
<p>距离的度量</p>
<p>无穷范数 x或y的最大值</p>
<h5 id="BN"><a href="#BN" class="headerlink" title="BN"></a>BN</h5><h5 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h5><ul>
<li><p>一阶方法<br>梯度下降</p>
</li>
<li><p>二阶方法<br>Hessian 矩阵，计算Hessian矩阵可以反映坡度的陡缓<br>牛顿法</p>
<p>用Hessian矩阵替代学习率-&gt;自适应<br>但计算量太大-&gt;近似算法</p>
</li>
<li><p>共轭牛顿法</p>
</li>
<li><p>伪牛顿法</p>
</li>
</ul>
<h5 id="随机梯度下降（SGD）的“随机”性体现"><a href="#随机梯度下降（SGD）的“随机”性体现" class="headerlink" title="随机梯度下降（SGD）的“随机”性体现"></a>随机梯度下降（SGD）的“随机”性体现</h5><p>SGD使用整个数据集的子集（mini-batch SGD）而不是完整的数据集迭代估计优化的最佳方向，因为整个数据集可能非常大，因而是随机的梯度下降并不能保证每一步都是最优方向。除SGD算法外，现在已有更多改进方案可用于计算权重的变化值进行权重优化，我们将在“优化方法”一节中进一步介绍。</p>
<h5 id="SGD改进"><a href="#SGD改进" class="headerlink" title="SGD改进"></a>SGD改进</h5><p>动量：跳出局部最小值和鞍点；解决poor conditioning（当损失函数在一个方向上改变很快而在另一方向改变很慢，使用普通SGD会出现在变化敏感方向上的锯齿跳动，这种情况在高维下很常见。动量项将先前权重更新的一小部分添加到当前权重更新中。如果两次更新在同一方向则会加快收敛，而更新在不同方向上时则会平滑方差，从而能够尽快结束这种情况下的曲折前进Zigzagging）</p>
<p>自适应学习方法</p>
<p>Adagrad: 记录所有梯度的平方和，使得能够在较缓的维度上除以一个较小值进行加速而在较陡的维度上除以一个较大值从而减速。但由于梯度的平方和越来越大，步幅会越来越小，可能会停在鞍点处无法出来，因而Adagrad只适用于卷积层的学习。</p>
<p>RMSprop: RMSprop在Adagrad基础上进行小幅改动，对梯度的平方和进行衰减，衰减率（decay rate）通常设为0.9或0.99。实现了指数移动平均，类似于lstm的遗忘门。</p>
<p>Adam综合上述两种方法和动量</p>
<h5 id="XGB"><a href="#XGB" class="headerlink" title="XGB"></a>XGB</h5><p>并行化的实现：特征值预排序</p>
<p>参数调优：</p>
<ul>
<li>正则项 gamma调叶子结点个数，lambda调叶子结点取值的L2模平方</li>
<li>early_stopping</li>
<li>shrinkage，学习率控制拟合速度，单步生成树的权重</li>
<li>列采样，同随机森林</li>
</ul>
<p>XGB VS GBDT</p>
<p>一阶 -&gt; 二阶泰勒展开</p>
<p>为什么使用二阶泰勒展开</p>
<p>使用二阶泰勒展开是为了xgboost能够自定义loss function，只要这个损失函数可以求二阶导</p>
<p>特征预排序</p>
<p>稀疏感知：将缺失值归为一个分支</p>
<p>直方图</p>
<p>LGB VS XGB</p>
<p>leaf-wise VS level-wise level-wise方便并行计算每一层的分裂节点，提高了训练速度，但同时也因为每一level中增益较小的节点分裂增加了很多不必要的分裂；leaf-wise每次分裂增益最大的叶子节点，但容易过拟合，需要控制好depth</p>
<p>直方图+GOSS （Gradient-based One-Side Sampling）单边梯度抽样算法</p>
<p>对梯度较小的样本随机抽样，保留梯度较大的样本</p>
<p>直方图加速</p>
<p>叶节点的直方图可以通过父节点的直方图与兄弟节点的直方图相减的方式构建</p>
<p><a href="https://cloud.tencent.com/developer/article/1534903" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1534903</a></p>
<p>CAT VS XGB</p>
<p>target statistic</p>
<h5 id="ROC-AUC"><a href="#ROC-AUC" class="headerlink" title="ROC AUC"></a>ROC AUC</h5><p>横坐标假阳性率，纵坐标真阳性率</p>
<p>统计正样本P、负样本N个数，横坐标划分1/N，纵坐标划分1/P，然后从原点出发正样本向上，负样本向右</p>
<h5 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h5><p>尺寸计算：输出维度公式 (n + 2p - f) / s + 1</p>
<p>采用same padding填充行数为 f - n % s</p>
<p>参数数量：filter_size <em> filter_size </em> out_channel + out_channel(每个out_channel对应一个偏置量) </p>
<h3 id="字节面试复盘"><a href="#字节面试复盘" class="headerlink" title="字节面试复盘"></a>字节面试复盘</h3><p>MLP代替点积的效果一定好？（推翻NCF的最新论文）</p>
<p>如何证明NN能学到特征交叉？</p>
<p>特征交叉的方式有哪些？</p>
<p>如何设计实验证明BN对ICS有效？</p>
<p>不同场景embedding怎么保证嵌入空间一致性？</p>
<p>（跨场景的vid embedding的使用方式）</p>
<p>召回离线评估</p>
<p>如何设计多样性评价指标？</p>
<p>召回阶段和排序阶段的样本构造差异？</p>
<p>随机负采样和曝光未点击负采样哪种方式效果更好？</p>
<p>TF模型的上线方式（不用tf-serving）</p>
<p>Xgb解决分类和回归问题的差异？多分类下节点的分裂方式？</p>
<p>线上线下不一致问题的坑有哪些？如何解决？</p>
<p>合并k个有序链表</p>
<p>字符串s匹配pattern串</p>
<p>python实现lr，kmeans</p>
<p>找到数组中第一个未出现的正整数 LC41</p>
<h3 id="百度面试复盘"><a href="#百度面试复盘" class="headerlink" title="百度面试复盘"></a>百度面试复盘</h3><p>推荐系统的bias有哪些？</p>
<p>bias 和时长/分发量消偏平滑间的差异</p>
<p>Parameter Server的实现原理</p>
<p>分布式一致性 数据并行/模型并行</p>
<p>解释共轭分布</p>
<p>TDM召回</p>
<p>EE召回的abtest结果分析，baseline过低？</p>
<p>python实现bandit算法</p>
<p>FM 优化后复杂度O(KN) VS FM的训练复杂度？</p>
<p>手写一个栈，以O(1)时间维护栈中最大值</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/06/05/embedding-recsys/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/05/embedding-recsys/" class="post-title-link" itemprop="url">Embedding在推荐系统中的应用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-05 12:04:26" itemprop="dateCreated datePublished" datetime="2020-06-05T12:04:26+08:00">2020-06-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-30 12:16:50" itemprop="dateModified" datetime="2020-06-30T12:16:50+08:00">2020-06-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/RecSys/" itemprop="url" rel="index"><span itemprop="name">RecSys</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">995</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Embedding在推荐系统中的应用"><a href="#Embedding在推荐系统中的应用" class="headerlink" title="Embedding在推荐系统中的应用"></a>Embedding在推荐系统中的应用</h4><p><img src="/Users/jingy/Library/Application Support/typora-user-images/image-20200525165327642.png" alt="image-20200525165327642"></p>
<p>embedding相当于one hot的平滑，one hot相当于embedding的max-pooling</p>
<p>embedding通常取神经网络倒数第二层的参数权重</p>
<p>embedding向量单独训练还是端到端训练？</p>
<p>单独训练的embedding训练样本大，参数学习充分；</p>
<p>端到端训练的embedding参数多，收敛速度慢，数据量少较难充分训练</p>
<p>embedding 静态表征</p>
<p>word2vec, fasttext, glove</p>
<p>embedding 动态表征</p>
<p>elmo 双向LSTM抽取特征</p>
<p>gpt 单向语言模型，transformer抽取特征，输入输出attention，不受长度限制易并行</p>
<p>bert 双向语言模型，transformer抽取特征，其他同上</p>
<p>i2i召回</p>
<p>tag2vec, 取文章的tag的fasttext生成的embeding等权重相加，faiss取相似，按相似度截断再利用热度，ctr等加权排序</p>
<p>item2vec，取文章id向量，取文章作者向量</p>
<p>loc2vec，地名对应向量</p>
<p>title2vec，lstm训练标题向量</p>
<p>doc2vec，bert计算文章文本向量</p>
<p>entity2vec，tranE生成实体向量</p>
<p>u2i召回</p>
<p>user2vec 用户tag向量和文章tag向量（多个tag的向量进行加权和，归一化）</p>
<p>对所有用户向量进行minibatch-kmeans聚为400簇（5k users per），簇内计算相似用户，写入天级redis，相似用户topn文章候选集去重计算相似度得分，根据相似度，热度，新鲜度，质量分，ctr加权形成倒排，写入天级redis</p>
<p>DSSM</p>
<p>crossTag，用户tag按类别统计，每个类别取k个tag，m组tag分别和用户tag向量计算相似度</p>
<p>分群召回</p>
<ol>
<li><p>簇召回：所有用户的tag向量或用户行为lstm向量用聚类算法（如minibatch-kmeans）聚成若干个簇（比如500个，根据肘点法确定），然后簇内做实时CF</p>
<ul>
<li>增量聚类，一段时间内保持聚类中心不变，新增数据点选择现有最近距离中心，业务低峰时期全量更新聚类中心</li>
<li>动态规则聚类，选择用户画像兴趣点组合作为兴趣标签，保留用户数超过阈值的兴趣标签作为聚类中心</li>
</ul>
<p>RFM模型用户分群</p>
</li>
<li><p>多用户融合作为群画像</p>
</li>
</ol>
<p><img src="/Users/jingy/Library/Application Support/typora-user-images/image-20200525230021916.png" alt="image-20200525230021916"></p>
<p><img src="/Users/jingy/Library/Application Support/typora-user-images/image-20200525230100683.png" alt="image-20200525230100683"></p>
<p><img src="/Users/jingy/Library/Application Support/typora-user-images/image-20200525230358968.png" alt="image-20200525230358968"></p>
<p>Embedding的问题和优化</p>
<p><img src="/Users/jingy/Library/Application Support/typora-user-images/image-20200525230436683.png" alt="image-20200525230436683"></p>
<p><img src="/Users/jingy/Library/Application Support/typora-user-images/image-20200525230514339.png" alt="image-20200525230514339"></p>
<p>总结</p>
<p><img src="/Users/jingy/Library/Application Support/typora-user-images/image-20200525230525617.png" alt="image-20200525230525617"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/06/01/multi-task-recsys/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/01/multi-task-recsys/" class="post-title-link" itemprop="url">多任务学习在推荐系统中的应用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-01 11:56:48" itemprop="dateCreated datePublished" datetime="2020-06-01T11:56:48+08:00">2020-06-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-21 10:46:16" itemprop="dateModified" datetime="2020-07-21T10:46:16+08:00">2020-07-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/RecSys/" itemprop="url" rel="index"><span itemprop="name">RecSys</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">516</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="Hard参数共享"><a href="#Hard参数共享" class="headerlink" title="Hard参数共享"></a>Hard参数共享</h5><p>所有任务共享底层参数，shared-bottom</p>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200720162726147.png" alt="image-20200720162726147"></p>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200720161902483.png" alt="image-20200720161902483"></p>
<p>优点：减少过拟合风险</p>
<p>缺点：效果可能受到任务差异和数据分布带来的影响</p>
<h5 id="Soft参数共享"><a href="#Soft参数共享" class="headerlink" title="Soft参数共享"></a>Soft参数共享</h5><p>不同任务的参数间增加约束控制任务的相似性，例如增加L2正则，trace norm</p>
<p>优点：在任务差异会影响公共参数的情况下对最终效果有提升</p>
<p>缺点：模型增加了参数量所以需要更大的数据量来训练模型，而且模型更复杂并不利于在真实生产环境中实际部署使用</p>
<h5 id="MOE-Mixture-of-Experts-模型"><a href="#MOE-Mixture-of-Experts-模型" class="headerlink" title="MOE(Mixture-of-Experts)模型"></a>MOE(<strong>Mixture-of-Experts</strong>)模型</h5><p>所有任务共享底层若干专家子网络，不同专家网络学习不同角度知识，上层利用门控结构进行加权融合。</p>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200720161846247.png" alt="image-20200720161846247"></p>
<p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200720161947020.png" alt="image-20200720161947020"></p>
<p>n个expert network，g是组合experts结果的gating network。g产生n个experts上的概率分布，最终的输出是<strong>所有experts的带权加和</strong>。</p>
<p>MoE可作为一个基本组成单元，堆叠在大网络中</p>
<h5 id="MMOE模型"><a href="#MMOE模型" class="headerlink" title="MMOE模型"></a>MMOE模型</h5><p><strong>shared-bottom网络中的函数f替换成MoE层</strong>，不同上层任务使用不同门控进行专家子网络的融合</p>
<p> <img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20200720163230408.png" alt="image-20200720163230408"></p>
<p>优点：不同任务的gating networks可以学习到不同的组合experts的模式，可以捕捉到任务的相关性和区别。</p>
<p>分层萃取共享，渐进式分离</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/05/28/match-recsys/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/28/match-recsys/" class="post-title-link" itemprop="url">推荐系统召回算法总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-28 22:23:24" itemprop="dateCreated datePublished" datetime="2020-05-28T22:23:24+08:00">2020-05-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-30 12:03:20" itemprop="dateModified" datetime="2020-06-30T12:03:20+08:00">2020-06-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/RecSys/" itemprop="url" rel="index"><span itemprop="name">RecSys</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">6.1k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">6 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="通用召回（非个性化）"><a href="#通用召回（非个性化）" class="headerlink" title="通用召回（非个性化）"></a>通用召回（非个性化）</h4><p>全局热门召回</p>
<p>热门即以全局后验统计概率估计用户点击的概率</p>
<p>热点事件bert召回</p>
<p>实时爬取新闻话题并对其进行bert向量预存，使用DBSCAN进行密度聚类，每个聚类中心作为事件向量根据热度时间等计算热度值；在item的bert向量中检索相似向量召回</p>
<h4 id="CB召回-content-based"><a href="#CB召回-content-based" class="headerlink" title="CB召回(content-based)"></a>CB召回(content-based)</h4><h5 id="属性标签召回"><a href="#属性标签召回" class="headerlink" title="属性标签召回"></a>属性标签召回</h5><p>tag、cate倒排</p>
<p>倒排优化：</p>
<p>问题：1. 点击率倒排，头部标题党；完成率倒排，头部短视频 2.后验指标置信度 3.倒排的优化目标与线上目标不一致，例如离线统计窗口的后验值和线上排序的状态并不契合，新的内容很难进入倒排的头部等</p>
<p>解决方案：</p>
<p>1.资源的后验分布与资源本身的类型有关，因此将视频根据时长和类别组合分桶，在桶内做z–score归一化，将完成率的分布收缩到准正态分布</p>
<p>2.置信阈值的判定</p>
<p>1）用分发趋势预估阈值的值-&gt;直接预估完成率，facebook热度预估模型</p>
<p>2）优化方差，在视频分发曲线上确定阈值点A，并在阈值点后取B点计算两点差值，累计所有人的差值和，求出总和最小的点作为阈值点</p>
<p>或CTR平滑，解决曝光量小导致的ctr置信度低的问题</p>
<p>1）手工平滑</p>
<p>将曝光分段，每段取24小时内的数据min-max归一化</p>
<p>2）指数平滑</p>
<p>$I_j = I_j, j =1$</p>
<p>$I_j = \beta I_j + (1 - \beta)I_{j-1}, j &gt; 1$</p>
<p>$I_N = \beta I_N + (1 - \beta) I_{N-1} = \beta I_N + \beta(1-\beta)I_{N-1} + … + \beta(1-\beta)^j I_{N-j} + … + \beta(1-\beta)^{N-1}I_1$</p>
<p>对曝光&lt;1000的数据不召回</p>
<p>3）Wilson平滑</p>
<p>一般效果最好</p>
<p>4）贝叶斯平滑</p>
<p>$ctr = (C_i + \alpha) / (I_i + \alpha + \beta) $</p>
<p>$\alpha$和$\beta$采用矩估计</p>
<p>总体而言，随着曝光次数的增加，对应的点击率是下降的，因此点击率需要考虑分发带来的衰减；不同类目下点击的行为也应有不同的权重，小众类目的点击比大众类目更有意义，tfidf；时间衰减可以修正处在置信阈值边界的兴趣点，即着时间推移没有新增兴趣表达的误判行为会逐渐衰减到阈值以下；对某一类目连续发生大量展现未点击的行为需要对其权重作降权。</p>
<p>3.倒排的优化 - 从统计到函数的趋势</p>
<p>使用视频信息构建模型，以倒排的目标（实际的完成率/点击率作为优化目标，以及时拟合线上的状况同时增加一定的泛化能力</p>
<p>聚焦置信点击率的后验值能够最大化提升推荐效果</p>
<p>触发tag、cate的优化：</p>
<p>用户不同的互动行为差异化权重</p>
<p>多term召回/多维度：</p>
<p>考虑内容的多维度属性，例如将内容的多个tag综合推荐而不是针对每个tag单独做倒排，即将用户的tag标签和内容的tag标签构造为sentence进行训练。</p>
<p>序列建模同时又会引入不同行为的序列权重的差异-&gt;更改word2vec的label生成逻辑和样本构造</p>
<p>word2vec优化<br>增量skip-gram 负采样</p>
<h5 id="基于内容的MF召回"><a href="#基于内容的MF召回" class="headerlink" title="基于内容的MF召回"></a>基于内容的MF召回</h5><p>基于内容的MF召回是通过评分矩阵经过矩阵分解和最小化目标函数学习得到用户和item的向量（对比：传统基于行为过滤的协同过滤方法是基于共现矩阵）</p>
<h4 id="CF召回（协同过滤）"><a href="#CF召回（协同过滤）" class="headerlink" title="CF召回（协同过滤）"></a>CF召回（协同过滤）</h4><h5 id="Memory-based-CF"><a href="#Memory-based-CF" class="headerlink" title="Memory-based CF"></a>Memory-based CF</h5><p>Item-based CF</p>
<p>划分窗口利用用户的点击历史，以窗口内内容id出现的条件概率作为后验预估</p>
<p>问题： 热点视频和大多数视频的共现概率都很高</p>
<p>解决：基于共现统计的cf在分母上乘视频的分发量抵消降权；item2vec本身集成word2vec高频负采样，这和数据的整体分布相关，如果参数设置不合理，分布和参数空间不match会折损训练效果；还有完成率建模带来的时长的bias，通常需要时长调权，归一化等</p>
<p>User-based CF</p>
<p>用户的相似度度量</p>
<p>jaccard对大数据量而言计算困难-&gt;simHash</p>
<p>用户list2list建模，利用孪生网络（适合稀疏分类问题）以用户是否为同一个用户作为label提供监督，在线召回使用bagging，不同用户间的差异化权重可以利用attention机制等学习。</p>
<h5 id="Model-based-CF"><a href="#Model-based-CF" class="headerlink" title="Model-based CF"></a>Model-based CF</h5><p>基于MF、SVD、pLSA、LDA的CF</p>
<h6 id="DSSM-DeepCF-MatchNet"><a href="#DSSM-DeepCF-MatchNet" class="headerlink" title="DSSM/DeepCF/MatchNet"></a>DSSM/DeepCF/MatchNet</h6><p>DSSM双塔，用户点击做正样本，全局随机采样负样本</p>
<p>如果使用展现未点击作负样本，召回结果会偏向热门，为什么？</p>
<p>DSSM优化</p>
<ul>
<li>user和item特征交叉</li>
</ul>
<p>uid的embedding直接连到瓶颈层把doc向量作增维，强化uid记忆性。为什么不连vid特征？</p>
<ul>
<li>增加attention、FM等结构增强模型表达能力，增加side-info</li>
</ul>
<p>在user侧增加attention，学习用户session内不同类型行为的权重</p>
<p>在item侧增加side info以强化长尾item特征缓解高热和attention，学习不同side info属性信息的主次</p>
<p>融合FM特征</p>
<ul>
<li>pair-wise双塔提升模型预测能力</li>
<li>multi-view DSSM 结合多业务信息丰富用户表达</li>
<li>多塔多目标，结合多业务指标</li>
</ul>
<p>CF的问题：</p>
<p>Icf时效性，新视频不容易出，即i2i 如果使用共现概率会存在新item的冷启动问题，但如果i2i基于内容本身的相似度，则可以很容易召回新的item。同理ucf会存在新用户和新item的冷启动问题。</p>
<p>解决方案：</p>
<p>icf中引入泛化特征side info，利用side info的共现信息。</p>
<p>lookalike 用户点击的一系列视频，其中某一个新视频可以通过邻近点击视频向量加权平均近似求得</p>
<h6 id="EGES"><a href="#EGES" class="headerlink" title="EGES"></a>EGES</h6><p>在行为向量基础上增加side info构成语义行为向量，以解决用户行为数量少的item的冷启动</p>
<p>用concat、avg pooling、self-attention和transformer encoder的方法融合side info</p>
<p><strong>Base Graph Embedding（BGE）</strong><br> user 的行为序列构建网络结构，并将网络定义为有向有权图。其中：根据行为的时间间隔，将一个 user 的行为序列分割为多个session进行deepwalk<br><strong>Graph Embedding with Side Information（GES）</strong><br>该方案增加 item 的额外信息（例如category, brand, price等）丰富 item 表征力度。根据 EGES的算法框架可知：<br>（1）item 和 side information（例如category, brand, price等） 的 Embedding 是通过 word2vec 算法一起训练得到的。如果分开训练，得到的item_embedding和category_embedding（brand_embedding， price_embedding）不在一个向量空间中，做运算无意义。<br>即：通过 DeepWalk 方案得到 item 的游走序列，同时得到对应的category（brand, price）序列。然后将所有序列数据放到word2vec模型中进行训练。<br>（2）针对每个 item，将得到：item_embedding，category_embedding，brand_embedding，price_embedding 等 embedding 信息。将这些 embedding 信息求均值来表示该 item<br><strong>Enhanced Graph Embedding with Side Information（EGES）</strong><br>组合表示 item_embedding 时，对 item 和 side information（例如category, brand, price等）的embedding施加不同的权重，用改进的word2vec算法（Weighted Skip-Gram）确定模型的参数。<br>Sparse Features代表 item 和 side information 的ID信息；<br>Dense Embeddings 表示 item 和 side information 的 embedding 信息；<br>alpha分别代表 item 和 side information 的 embedding 权重；<br>Sampled Softmax Classifier中的N代表采样的负样本（见论文中的Algorithm 2 Weighted Skip-Gram描述的第8行），P代表正样本（某个item周边上下n个item均为正样本，在模型中表示时不区分远近）；</p>
<h6 id="Youtube-DNN"><a href="#Youtube-DNN" class="headerlink" title="Youtube DNN"></a>Youtube DNN</h6><p><strong>训练集</strong><br>对每个用户提取等数量的训练样本，防止高度活跃用户对于loss的过度影响。<br><strong>测试集</strong><br>YouTube为什么不采用经典的随机留一法（random holdout），而是一定要把用户最近的一次观看行为作为测试集，避免引入future information，产生与事实不符的数据穿越。<br>video embedding的时候，要直接把大量长尾的video直接用0向量代替<br><strong>输入处理：</strong><br>样本通过spark处理为tfrecord，传至ceph，输入采用Dataset多线程读取</p>
<p><strong>特征处理：</strong></p>
<p>多值离散特征，例如历史播放列表、搜索词表：获取每个词的embedding平均求和得到固定长度隐向量</p>
<p>单值离散特征，例如地理位置，获取固定长度embedding向量</p>
<p>单值连续特征：年龄、性别：年龄构造平方、开方项</p>
<p><strong>模型结构：</strong></p>
<p>将上述三类特征concat，传入三层全连接层，使用ReLU函数，输入固定维度的user向量。</p>
<p><strong>损失函数：</strong></p>
<p>损失函数为softmax多分类交叉熵。将一次训练样本的播放vid作为正样本，多分类问题的类目个数为vid的数量，最后一层输出的user向量和vid向量的内积加上偏置表示user对该vid的感兴趣程度$z_i = u ·I_i + b_i$，然后通过softmax函数将所有感兴趣程度转化为概率：</p>
<p>$p_i = \frac{e^{z_i}}{\Sigma_j e^{z_j} }$，利用交叉熵得到损失函数：$L=- \Sigma_i y_i·log(p_i)$，其中$y_i$是一个vid数量维度的one-hot向量，只有被播放的视频对应一维是1，其余为0，可以采用负采样降低0的维度数量。</p>
<p><strong>输出：</strong></p>
<p>DNN 最后一层为user的embedding表示，softmax的权重为item的embedding表示</p>
<p><strong>线上serving：</strong></p>
<p>使用faiss进行topk search</p>
<p>Faiss支持l2欧式距离和IP内积的方式，但基于内积的方式需要user和item向量均是归一化向量，但youtube DNN模型训练时不进行向量的l2归一化，因此需要使用在原向量中增加一维，将内积问题转换为欧式距离问题来解决</p>
<p>MIP(maximum inner product)2NN(nearest neighbor)<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/XboxInnerProduct.pdf" target="_blank" rel="noopener">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/XboxInnerProduct.pdf</a></p>
<p><strong>样本不平衡问题</strong></p>
<p>使用Focal Loss</p>
<p>clip gradient 可以缓解梯度爆炸 / 防止出现网络训练中出现NaN</p>
<p>Triplet loss通常配合OHEM(online hard example mining)</p>
<p>权值共享： 多个特征的同一概念embedding的look_up table共享</p>
<p>基于牛顿冷却定律的时间衰减</p>
<p><strong>负采样</strong></p>
<ol>
<li><p>tf.sample_softmax_loss调用log_uniform_candidate_sampler负采样，数值越小被采样的概率越大，因此对于vid，按照其在所有用户播放历史中出现的次数降序排列，标号越小出现次数越大，0保留用于替换确实值。但这样也会导致头部效应。可以采用word2vec论文或源码中的高频采样公式构造样本：</p>
<p>$ran = (\sqrt{\frac{x}{0.001}} + 1)*(0.001/x)$，使高频词被保留的概率更小。</p>
</li>
<li><p>NEG（negative）采样代替softmax，tf.nn.learned_unigram_candidate_sampler。噪声对比估计(NCE,Noise-Contrastive Estimation)，它将点击样本的softmax变为多个二分类logistic问题。由于softmax具有sum-to-one的性质，最大化点击样本的概率必然能导致最小化非点击样本的概率，而二分类logistic则没有这个性质，所以需要人为指定负样本，NCE就是一种<strong>根据热度随机选取负样本</strong>的技术，通过优化NCE损失，可以快速地训练得到模型的所有参数。在实践中，我们采用了TensorFlow提供的函数tf.nn.nce_loss去做候选采样并计算NCE损失。</p>
</li>
</ol>
<p><strong>user embedding和item embedding如何保证在同一个空间</strong><br>和dssm类似，都是通过内积限制两个embedding在相同空间，在CF中可以通过矩阵分解得到user和vedio的向量表示，这里最后的softmax相当于广义矩阵分解，模型最后一层隐层就是user embedding，通过u*v得到vedio的概率，v就是vedio embedding，只不过这里用来作为softmax层的权重；最后一层输出的user向量和vid向量的内积加上偏置表示user对该vid的感兴趣程度，然后通过softmax函数将所有感兴趣程度转化为概率</p>
<p><strong>和排序模型的差异：</strong><br>引入另一套DNN作为ranking model的目的就是引入更多描述视频、用户以及二者之间关系的特征，例如language embedding: 用户语言的embedding和当前视频语言的embedding<br>time since last watch: 自上次观看同channel视频的时间</p>
<p>previous impressions: 该视频已经被曝光给该用户的次数</p>
<p>example age，倾向于新视频，sample log距离当前时间，预测时置为0保证预测时处于训练的最后一刻<br>此外，ranking model不采用经典的logistic regression当作输出层，而是采用了weighted logistic regression</p>
<h4 id="召回的评估问题"><a href="#召回的评估问题" class="headerlink" title="召回的评估问题"></a>召回的评估问题</h4><p>相关性高能否代表召回效果有提升？</p>
<p>相关性提升到80以上后应该更关注效果</p>
<p>召回占比的提升</p>
<p>排序时这一路召回q值的提升还要关注其分布，是否均值变小方差变大，以及这路召回的uniq占比</p>
<p>MRR指标</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/05/28/mf/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/28/mf/" class="post-title-link" itemprop="url">矩阵分解MF原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-28 19:07:58" itemprop="dateCreated datePublished" datetime="2020-05-28T19:07:58+08:00">2020-05-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-30 11:24:02" itemprop="dateModified" datetime="2020-06-30T11:24:02+08:00">2020-06-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/RecSys/" itemprop="url" rel="index"><span itemprop="name">RecSys</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">0</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/05/28/kg-recsys/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/28/kg-recsys/" class="post-title-link" itemprop="url">知识图谱在推荐系统的应用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-28 17:09:09 / 修改时间：18:33:00" itemprop="dateCreated datePublished" datetime="2020-05-28T17:09:09+08:00">2020-05-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/RecSys/" itemprop="url" rel="index"><span itemprop="name">RecSys</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">704</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>知识图谱引入推荐系统的两类方式：</p>
<h4 id="基于特征的方法"><a href="#基于特征的方法" class="headerlink" title="基于特征的方法"></a>基于特征的方法</h4><p>利用知识图谱得到实体、关系的embedding</p>
<p>学习方式：</p>
<ul>
<li>分别学习</li>
</ul>
<p>DKN（Deep Knowledge-aware Network）</p>
<p>首先通过实体链接将新闻标题文本中实体链接到知识图谱，获得实体的实体特征和上下文实体特征（所有一跳邻居节点的实体上下文特征的均值）。</p>
<p>将新闻标题词向量、实体向量、实体上下文向量作为多通道使用CNN融合得到candidate的embedding；用户历史兴趣通过attention机制结合candidate embedding学习不同的权重作为user embedding；Candidate embedding和user embedding经过concat通过mlp预测点击率。</p>
<ul>
<li>交替学习（多任务学习）</li>
</ul>
<p>MKR（Multi-task ）</p>
<p>推荐网络使用user和item特征预测点击率；知识图谱网络使用三元组的头节点和关系表示作为输入预测尾节点；两者通过交叉特征共享单元链接，然后分别固定一侧网络参数交替训练。</p>
<ul>
<li>联合学习（end2end）</li>
</ul>
<p>CKE（collaborative knowledge base embedding）</p>
<p>知识图谱实体表示和图像表示、文本表示三类目标函数与协同过滤结合得到联合损失函数训练</p>
<p>Ripple Network</p>
<p>以用户历史记录为中心在图谱上扩散，并在扩散过程中衰减得到item embedding和user embedding，使用联合损失函数训练</p>
<p>KGAT</p>
<p>GCN建模，邻居节点使用注意力机制融合，使用联合损失函数训练</p>
<h4 id="基于结构的方法"><a href="#基于结构的方法" class="headerlink" title="基于结构的方法"></a>基于结构的方法</h4><p>利用知识图谱使用bfs、dfs得到多跳关联实体</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/03/21/common-error/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/21/common-error/" class="post-title-link" itemprop="url">面试复盘</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-21 15:37:43" itemprop="dateCreated datePublished" datetime="2020-03-21T15:37:43+08:00">2020-03-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-21 10:46:16" itemprop="dateModified" datetime="2020-07-21T10:46:16+08:00">2020-07-21</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">632</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近期面试反省，虽然这段时间一直在积极准备算法题，但发现真正面试时尝试白板编程实现bug-free还是存在不少问题，在面试氛围下进行肉眼debug也比平常更难发现错误。这说明代码实现的熟练度还是不够，日常的训练缺少肉眼debug争取一次性通过的练习，仍然比较依赖编译器和调试过程，故这里对自己常见的失误和bug进行记录以供自我提醒。</p>
<ol>
<li><p>循环结束条件，忘记break，例如双指针循环条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (j &lt; n &amp;&amp; a[i] == a[j]) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">// 条件直接&amp;&amp;在while判断内, 如果采用if形式循环内注意结束条件,否则如果不落在if条件中则会死循环</span><br><span class="line">while (j &lt; n) &#123;</span><br><span class="line">	if (a[i] == a[j])</span><br><span class="line">		j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>for循环指针直接跳转，忘记惯写的i++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">	int j;</span><br><span class="line">	...</span><br><span class="line">	i = j;</span><br><span class="line">&#125;</span><br><span class="line">for循环执行后i++，因此i应该等于j-1才能在下次循环从j起始</span><br></pre></td></tr></table></figure>
</li>
<li><p>二分必须sorted array或至少满足区间两端划分性质，例如重建二叉树，在中序遍历中寻找根节点值的位置，可以通过预处理建立中序数组值和下标的哈希表O(1)时间查找；如果存在重复元素那只能暴力遍历搜索，因为中序数组的无序性也无法使用lower_bound。</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/02/03/algo-template2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/03/algo-template2/" class="post-title-link" itemprop="url">算法模版-中级篇</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-03 19:39:44" itemprop="dateCreated datePublished" datetime="2020-02-03T19:39:44+08:00">2020-02-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-09 12:22:43" itemprop="dateModified" datetime="2020-06-09T12:22:43+08:00">2020-06-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">21 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li>离散化</li>
<li>二分判定</li>
<li>区间合并/区间贪心调度</li>
<li>前缀和/差分</li>
<li>树状数组</li>
<li>线段树</li>
<li>图论</li>
<li>字符串匹配</li>
<li>Trie树</li>
<li>动态规划</li>
</ol>
<h4 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h4><p>待离散值排序、去重，然后二分求离散化对应坐标</p>
<p>单值离散化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; all;</span><br><span class="line">sort(all.begin(), all.end());</span><br><span class="line">all.erase(unique(all.begin(), all.end()), all.end());</span><br><span class="line"></span><br><span class="line">// 待离散化值y-&gt;离散化后x</span><br><span class="line">int x = find(all.begin(), all.end(), y) - all.begin();</span><br><span class="line">// or</span><br><span class="line">int bs(int k) &#123;</span><br><span class="line">    int l = 0, r = all.size() - 1;</span><br><span class="line">    while(l &lt; r) &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (all[mid] &gt;= k) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r + 1;</span><br><span class="line">&#125;</span><br><span class="line">int x = bs(y);</span><br></pre></td></tr></table></figure>
<p>线段坐标离散化</p>
<p>每个端点需要考虑其本身和前后两点，从而将线段压缩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int compress(vector&lt;int&gt; &amp;x1, vector&lt;int&gt; &amp;x2, int w) &#123;</span><br><span class="line">	vector&lt;int&gt; all;</span><br><span class="line">	for (int i = 0; i &lt; x1.size(); i++) &#123;</span><br><span class="line">		for (int d = -1; d &lt;= 1; d++) &#123;</span><br><span class="line">			int tx1 = x1[i] + d, tx2 = x2[i] + d;</span><br><span class="line">			if (tx1 &gt;= 1 &amp;&amp; tx1 &lt;= w) all.push_back(tx1);</span><br><span class="line">			if (tx2 &gt;= 1 &amp;&amp; tx2 &lt;= w) all.push_back(tx2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	sort(all.begin(), all.end());</span><br><span class="line">	all.erase(unique(all.begin(), all.end()), all.end());</span><br><span class="line">	</span><br><span class="line">	for (int i = 0; i &lt; x1.size(); i++) &#123;</span><br><span class="line">		x1[i] = find(all.begin(), all.end(), x1[i]) - all.begin();</span><br><span class="line">		x2[i] = find(all.begin(), all.end(), x2[i]) - all.begin();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return all.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分判定"><a href="#二分判定" class="headerlink" title="二分判定"></a>二分判定</h4><p>给定N个数，将其分为X组，每组K = N / X个数且需要保证K个数互不重复，求出每组最大数和最小数间的差值，求能够实现的所有组该差值总和的最小值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool check(int n, int k, vector&lt;int&gt;&amp; a, int mid) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int xGroup(int n, int k, vector&lt;int&gt;&amp; a) &#123;</span><br><span class="line">	int maxn = 0, minn = 2e9;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		minn = min(a[i], minn);</span><br><span class="line">		maxn = max(a[i], maxn);</span><br><span class="line">	&#125;</span><br><span class="line">	int l = 0, r = (maxn - minn) * (n / k);</span><br><span class="line">	while (l &lt; r) &#123;</span><br><span class="line">		int mid = l + r &gt;&gt; 1;</span><br><span class="line">		if (check(n, k, a, mid)) r = mid;</span><br><span class="line">		else l = mid + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h4><h5 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h5><p>按区间左端点排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void merge(vector&lt;PII&gt; &amp; segs) &#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    sort(segs.begin(), segs.end());</span><br><span class="line">    int st = -2e9, ed = -2e9; </span><br><span class="line">    for(auto seg : segs) &#123;</span><br><span class="line">        if (ed &lt; seg.first) &#123;</span><br><span class="line">            if (st != -2e9) </span><br><span class="line">                res.push_back(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first;</span><br><span class="line">            ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            ed = max(ed, seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    if (st != -2e9) &#123;</span><br><span class="line">        res.push_back(&#123;st, ed&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a>区间覆盖问题</h5><h6 id="求覆盖各区间的最少点数-每个区间至少包含一个点"><a href="#求覆盖各区间的最少点数-每个区间至少包含一个点" class="headerlink" title="求覆盖各区间的最少点数(每个区间至少包含一个点)"></a>求覆盖各区间的最少点数(每个区间至少包含一个点)</h6><p>按区间右端点排序，选取最右点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"></span><br><span class="line">bool cmp(const PII &amp;a, const PII &amp;b) &#123;</span><br><span class="line">    return a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    int a, b;</span><br><span class="line">    vector&lt;PII&gt; v;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        v.push_back(&#123;a, b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(), v.end(), cmp);</span><br><span class="line">    int res = 0, ed = -2e9;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (ed &lt; v[i].first) &#123;</span><br><span class="line">            ed = v[i].second;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="区间调度问题-求不相交区间的最多区间数目"><a href="#区间调度问题-求不相交区间的最多区间数目" class="headerlink" title="区间调度问题/求不相交区间的最多区间数目"></a>区间调度问题/求不相交区间的最多区间数目</h6><p>如果最多有x个不相交区间，那么就至少需要x个点覆盖所有区间，因为本题和上一题等价，只有区间边界可能略有不同</p>
<p>选取结束时间最早的活动 -&gt; 按区间右端点排序，选取max_ed和下一个区间起始不相交的位置</p>
<h6 id="求按照不相交区间分组的最少分组数目"><a href="#求按照不相交区间分组的最少分组数目" class="headerlink" title="求按照不相交区间分组的最少分组数目"></a>求按照不相交区间分组的最少分组数目</h6><p>按区间左端点排序，记录每个组的最右坐标，依次枚举每个区间能否加入各个组，如果不能则新开一组。实际上枚举每个区间是否有可加入的组只需要找右坐标最小的组即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define  l first</span><br><span class="line">#define  r second</span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;PII&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        a[i] = &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (que.empty() || a[i].l &lt;= que.top()) &#123;</span><br><span class="line">            que.push(a[i].r);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            que.pop();</span><br><span class="line">            que.push(a[i].r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; que.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="求覆盖指定线段的最少区间数目"><a href="#求覆盖指定线段的最少区间数目" class="headerlink" title="求覆盖指定线段的最少区间数目"></a>求覆盖指定线段的最少区间数目</h6><p>按区间左端点排序，依次枚举选取满足左端点在线段左侧的右端点最大的区间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sort(range, range + n);</span><br><span class="line"></span><br><span class="line">int res = 0;</span><br><span class="line">bool success = false;</span><br><span class="line">for (int i = 0; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    int j = i, r = -2e9;</span><br><span class="line">    while (j &lt; n &amp;&amp; range[j].l &lt;= st) &#123;</span><br><span class="line">        r = max(r, range[j].r);</span><br><span class="line">        j ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r &lt; st) &#123;</span><br><span class="line">        res = -1;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res ++ ;</span><br><span class="line">    if (r &gt;= ed) &#123;</span><br><span class="line">        success = true;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st = r;</span><br><span class="line">    i = j - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!success) res = -1;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>#####区间交集问题</p>
<p>两区间[x1, y1]和[x2, y2]不存在交集的条件是 <code>y1 &lt; x2 || y2 &lt; x1</code>，反之，则交集区间是<code>[max(x1, x2), min(y1, y2)]</code></p>
<h4 id="前缀和-差分"><a href="#前缀和-差分" class="headerlink" title="前缀和/差分"></a>前缀和/差分</h4><h5 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h5><p>为便于计算，下标从1开始</p>
<p><code>s[0] = a[0] = 0</code></p>
<p><code>s[i] = s[i-1] + a[i];</code></p>
<p>求区间[l, r]元素和<code>s[r] - s[l-1]</code></p>
<h5 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h5><p><code>s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]</code></p>
<p>求区间[(x1, y1), (x2, y2)]元素和<code>s[x2][y2] - s[x1-1][y1] - s[x1][y1-1] + s[x1-1][y1-1]</code></p>
<h5 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h5><p>差分可看作前缀和的逆操作，可实现$O(1)$时间的区间修改和单点修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void modify(int l, int r, int c) &#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r+1] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 复原原矩阵更新后的值</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    b[i] += b[i-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const int N = 1005; // 注意数组从1开始且设计N+1，N至少要大于等于2 </span><br><span class="line">int b[N][N];</span><br><span class="line"></span><br><span class="line">void modify(int x1, int y1, int x2, int y2, int c) &#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2+1][y1] -= c;</span><br><span class="line">    b[x1][y2+1] -= c;</span><br><span class="line">    b[x2+1][y2+1] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 复原原矩阵更新后的值</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">  for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">  	b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="差分-贪心"><a href="#差分-贪心" class="headerlink" title="差分+贪心"></a>差分+贪心</h6><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.acwing.com%2Fsolution%2FAcWing%2Fcontent%2F816%2F" target="_blank" rel="noopener">求区间内所有值通过区间加1/减1全部相等的最小变换次数</a></p>
<h6 id="差分-前缀和"><a href="#差分-前缀和" class="headerlink" title="差分+前缀和"></a>差分+前缀和</h6><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.acwing.com%2Fsolution%2FAcWing%2Fcontent%2F817%2F" target="_blank" rel="noopener">满足互相看见约束的序列各位置的最高可能高度</a></p>
<h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>树状数组是支持区间单点修改的前缀和</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gchu0dzxigj30yg0hw3zs.jpg" alt=""><br>将上图所有区间从左至右按序排列，其区间长度的二进制表示为：<br>1,10,1, 100, 1,   10,  1,    1000<br>而图中区间标号对应的二进制表示为：<br>1,10,11,100,101,110,111,1000<br>用lowbit函数将区间标号映射为区间长度：区间长度即区间标号二进制表示从右往左出现第一个1以及这个1之后的那些0组成数的二进制对应的十进制的数。</p>
<p>区间标号映射区间长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(int x) &#123;</span><br><span class="line">	return x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化空间$O(n)$，注意下标从1到n</p>
<p>单点修改操作需要更新所有包含它的区间，时间复杂度$O(log n)$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int tr[N];</span><br><span class="line"></span><br><span class="line">void add(int x, int c) &#123;</span><br><span class="line">	for (int i = x; i &lt;= n; i += lowbit(i)) </span><br><span class="line">		tr[i] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间查询需要查询分支包含的所有区间，时间复杂度$O(log n)$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// a[1]...a[x]</span><br><span class="line">int presum(int x) &#123;</span><br><span class="line">  int res = 0;</span><br><span class="line">  for (int i = x; i; i -= lowbit(i))</span><br><span class="line">  	res += tr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// a[i]...a[j]</span><br><span class="line">int sum(int i, int j)</span><br><span class="line">  return presum(j) - presum(i-1);</span><br></pre></td></tr></table></figure>
<p>e.x. 计算右侧小于当前元素的个数</p>
<h5 id="差分-树状数组"><a href="#差分-树状数组" class="headerlink" title="差分+树状数组"></a>差分+树状数组</h5><p>可实现区间修改、单点查询或区间修改、区间查询</p>
<h5 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h5><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>五类操作， 四倍空间，初始化复杂度$O(n)$，区间操作查询或更新复杂度均为$O(\lg n)$</p>
<p>pushdown操作用于区间修改时的懒标记（仅支持单点修改时不需要），在区间修改和查询需要分裂区间前调用</p>
<h5 id="支持单点修改的区间最大值查询"><a href="#支持单点修改的区间最大值查询" class="headerlink" title="支持单点修改的区间最大值查询"></a>支持单点修改的区间最大值查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">const int N = 200010;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int l, r;</span><br><span class="line">    int v;</span><br><span class="line">&#125;tr[N * 4];</span><br><span class="line"></span><br><span class="line">void pushup(int u) &#123;</span><br><span class="line">    tr[u].v = max(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int u, int l, int r) &#123;</span><br><span class="line">    tr[u] = &#123;l, r&#125;;</span><br><span class="line">    if (l == r) return;</span><br><span class="line">    int mid = l + r &gt;&gt; 1;</span><br><span class="line">    build(u &lt;&lt; 1, l, mid);</span><br><span class="line">    build(u &lt;&lt; 1 | 1, mid + 1, r);</span><br><span class="line">    // 如果初始化时对v有修改，则需要调用pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 单点修改</span><br><span class="line">void modify(int u, int x, int v) &#123;</span><br><span class="line">    if (tr[u].l == x &amp;&amp; tr[u].r == x) </span><br><span class="line">        tr[u].v = v;</span><br><span class="line">    else &#123;</span><br><span class="line">        int mid = tr[u].l + tr[u].r &gt;&gt; 1;</span><br><span class="line">        if (x &lt;= mid) modify(u &lt;&lt; 1, x, v);</span><br><span class="line">        else modify(u &lt;&lt; 1 | 1, x, v);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int u, int l, int r) &#123;</span><br><span class="line">    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) </span><br><span class="line">        return tr[u].v;</span><br><span class="line">    int mid = tr[u].l + tr[u].r &gt;&gt; 1;</span><br><span class="line">    int v = 0;</span><br><span class="line">    // 注意递归调用的查询区间仍然是[l, r]，使用[l, mid]可以会放大空间</span><br><span class="line">    if (l &lt;= mid) v = query(u &lt;&lt; 1, l, r);</span><br><span class="line">    if (r &gt; mid) v = max(v, query(u &lt;&lt; 1 | 1, l, r));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int m, p;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    int n = 0, last = 0;</span><br><span class="line">    build(1, 1, m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        char op;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        if (op == &apos;Q&apos;) &#123;</span><br><span class="line">            last = query(1, n-x+1, n);</span><br><span class="line">            cout &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            modify(1, n+1, (x + last) % p);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="支持区间修改的区间和查询"><a href="#支持区间修改的区间和查询" class="headerlink" title="支持区间修改的区间和查询"></a>支持区间修改的区间和查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100010;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int a[N];</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int l, r;</span><br><span class="line">    ll sum, add;</span><br><span class="line">&#125;tr[N * 4];</span><br><span class="line"></span><br><span class="line">void pushup(int u) &#123;</span><br><span class="line">    tr[u].sum = tr[u&lt;&lt;1].sum + tr[u &lt;&lt; 1 | 1].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pushdown(int u) &#123;</span><br><span class="line">    auto &amp;root = tr[u], &amp;left = tr[u&lt;&lt;1], &amp;right = tr[u &lt;&lt; 1 | 1];</span><br><span class="line">    if (root.add) &#123;</span><br><span class="line">        left.add += root.add;</span><br><span class="line">        left.sum += (ll)(left.r - left.l + 1) * root.add;</span><br><span class="line">        right.add += root.add;</span><br><span class="line">        right.sum += (ll)(right.r - right.l + 1) * root.add;</span><br><span class="line">        root.add = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int u, int l, int r) &#123;</span><br><span class="line">    if (l == r) tr[u] = &#123;l, r, a[l], 0&#125;;</span><br><span class="line">    else &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        build(u &lt;&lt; 1, l, mid);</span><br><span class="line">        build(u &lt;&lt; 1 | 1, mid + 1, r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 区间修改</span><br><span class="line">void modify(int u, int l, int r, int d) &#123;</span><br><span class="line">    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">        tr[u].sum += (ll)(tr[u].r - tr[u].l + 1) * d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pushdown(u);</span><br><span class="line">        int mid = tr[u].l + tr[u].r &gt;&gt; 1;</span><br><span class="line">        if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, d);</span><br><span class="line">        if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, d);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll query(int u, int l, int r) &#123;</span><br><span class="line">    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) </span><br><span class="line">        return tr[u].sum;</span><br><span class="line">    pushdown(u);</span><br><span class="line">    int mid = tr[u].l + tr[u].r &gt;&gt; 1;</span><br><span class="line">    ll v = 0;</span><br><span class="line">    if (l &lt;= mid) v = query(u &lt;&lt; 1, l, r);</span><br><span class="line">    if (r &gt; mid) v += query(u &lt;&lt; 1 | 1, l, r);</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    build(1, 1, n);</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int l, r, d;</span><br><span class="line">        char op;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        if (op == &apos;C&apos;) &#123;</span><br><span class="line">            cin &gt;&gt; d;</span><br><span class="line">            modify(1, l, r, d);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; query(1, l, r) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h4><p>邻接矩阵<br><code>int G [maxv][maxv]</code>或<code>&lt;vector&lt;vector&lt;int&gt; &gt; G</code></p>
<p>邻接表<br><code>vector&lt;int&gt; G[maxv]</code></p>
<p><code>struct edge {
  int to;
  int cost;
}</code><br><code>vector&lt;edge&gt; G[maxv]</code></p>
<h5 id="BFS-DFS搜索"><a href="#BFS-DFS搜索" class="headerlink" title="BFS/DFS搜索"></a>BFS/DFS搜索</h5><p>时间复杂度均为$O(V+ E)$</p>
<h5 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; G[maxv];</span><br><span class="line">int color[maxv];</span><br><span class="line">int V;</span><br><span class="line"></span><br><span class="line">bool dfs(int v, int c) &#123;</span><br><span class="line">	color[v] = c;</span><br><span class="line">	for (int i = 0; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">		if (color[G[v][i]] == c) return false;</span><br><span class="line">		if (color[G[v][i] == 0 &amp;&amp; !dfs(G[v][i], -c)) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check() &#123;</span><br><span class="line">	bool flag = true;</span><br><span class="line">	for (int i = 0; i &lt; V; i++)</span><br><span class="line">		if (color[i] == 0)</span><br><span class="line">			if (!dfs(i, 1)) &#123;</span><br><span class="line">				flag = false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">	return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><p>拓扑图（可以拓扑排序的图） 等价于有向无环图DAG</p>
<p>将入度为0点入队，出队去边减去相关入度将入度为0点入队，队列元素即拓扑序，队列元素小于顶点数说明可能存在重边和自环，拓扑序列不存在</p>
<p>$O(V+E)$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100001;</span><br><span class="line">vector&lt;int&gt; G[N];</span><br><span class="line">int d[N]; // 入度数</span><br><span class="line">int n, m;</span><br><span class="line">// 使用stl queue元素会pop出队需要另开数组单独记录结果或者直接使用数组模拟队列</span><br><span class="line">vector&lt;int&gt; res; </span><br><span class="line"></span><br><span class="line">bool topsort() &#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    // 如果最终拓扑序需要按字典序输出，则将队列改为小根堆</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) </span><br><span class="line">        if (!d[i]) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">            res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    while (q.size()) &#123;</span><br><span class="line">        int t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for (int i = 0; i &lt; G[t].size(); i++)</span><br><span class="line">            if (--d[G[t][i]] == 0) &#123;</span><br><span class="line">                q.push(G[t][i]);</span><br><span class="line">                res.push_back(G[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res.size() == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!topsort()) cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) </span><br><span class="line">            cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h5><h6 id="Bellman-Ford-允许负环"><a href="#Bellman-Ford-允许负环" class="headerlink" title="Bellman-Ford 允许负环"></a>Bellman-Ford 允许负环</h6><p>每条边松弛|V| -1次（最坏情况下每次循环只松弛了一条边）之后如果存在不满足三角不等式的结点v.d &gt; u.d + w(u,v)说明存在负权重环</p>
<p>时间复杂度$O(VE)$</p>
<p>优化 - 拓扑排序后按序松弛</p>
<h6 id="Dijkstra-不许负权重边"><a href="#Dijkstra-不许负权重边" class="headerlink" title="Dijkstra 不许负权重边"></a>Dijkstra 不许负权重边</h6><p>维护一个已求出最短路径节点的集合S，以v.d为key构造最小堆，每次选择V-S中的最小堆顶，将其加入S并松弛所有与其相邻的边。注意第一次执行循环extract-min得到的是源点s</p>
<p>优先队列实现时间复杂度$O(VE)$</p>
<h6 id="Floyd-适用负权重边，不允许存在负权重环"><a href="#Floyd-适用负权重边，不允许存在负权重环" class="headerlink" title="Floyd 适用负权重边，不允许存在负权重环"></a>Floyd 适用负权重边，不允许存在负权重环</h6><p> 时间复杂度$O(V^3)$</p>
<h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>Kruskal算法：集合A是森林，按权重从低到高考察每条边，如果它将两棵不同的树连接起来就加入到森林A里并完成两棵树的合并</p>
<p>Prim算法：集合A是一棵树，每次加入连接集合A和A之外结点的所有边中权重最小的边</p>
<p>用并查集和优先队列分别实现，时间复杂度均为$O(ElgV)$</p>
<h4 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h4><h5 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5><p>时间复杂度$O(n-m+1)*m$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= (n - m + 1); i++) &#123;</span><br><span class="line">	bool flag = true;</span><br><span class="line">	for (int j = 1; j &lt;= m; j++) </span><br><span class="line">		if (s[i + j - 1] != p[j]) &#123;</span><br><span class="line">			flag = false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">return flag;</span><br></pre></td></tr></table></figure>
<h5 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h5><p>前缀函数 $\pi[q]$是能构成$P_q (即P[1…q])$<strong>真</strong>后缀的P的最长前缀长度<br>$\pi[q] = max(k : k &lt; q 且 P_k \sqsupset P_q)$</p>
<p>next[i]表示以p[i]结尾的p的子串的前缀函数值，即next[i] = j 表示 p[1…j] == p[i - j + 1…i]</p>
<p>预处理阶段摊还分析，时间复杂度$\Theta(m)$，因为j最多++ m次，因此while循环最多执行m次，同理匹配阶段时间复杂度$\Theta(n)$</p>
<p>字符串下标从1开始，next[1] = 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待匹配串s，模式串p，下标从1开始</span></span><br><span class="line"><span class="keyword">int</span> n+<span class="number">1</span> = s.size();</span><br><span class="line"><span class="keyword">int</span> m+<span class="number">1</span> = p.size();</span><br><span class="line"><span class="comment">// 求next数组, next[1] = 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">  <span class="keyword">if</span> (p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">  ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kmp匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="comment">// j表示当前模版串下一个要匹配位置的前一位</span></span><br><span class="line">  <span class="comment">// j == 0 表示j退回到起点</span></span><br><span class="line">  <span class="comment">// 如果j下一个位置不能匹配，则匹配串需要后移j-next[j]步，新的匹配末端位置即j-(j-next[j])</span></span><br><span class="line">  <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">  <span class="keyword">if</span> (s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">  <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">    j = ne[j];</span><br><span class="line">    <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">		<span class="comment">//e.x. cout &lt;&lt; i - m &lt;&lt; endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串下标从0开始，next[0] = -1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ne[0] = -1;</span><br><span class="line">for (int i = 1, j = -1; i &lt; m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    while (j &gt;= 0 &amp;&amp; p[j + 1] != p[i]) j = ne[j];</span><br><span class="line">    if (p[j + 1] == p[i]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0, j = -1; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];</span><br><span class="line">    if (s[i] == p[j + 1]) j ++ ;</span><br><span class="line">    if (j == m - 1) cout &lt;&lt; i - j &lt;&lt; &apos; &apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h4><p>高效存储和查询字符串的集合</p>
<p>插入和查询时间复杂度$O(\log n)$，时间复杂度$O(n^2)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>]; <span class="comment">// Trie树每个节点的字节点，此处英文字母只包含26个小写字母</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];<span class="comment">// 以当前这个点结尾的单词数量</span></span><br><span class="line"><span class="keyword">int</span> idx; <span class="comment">// 表示层数下标，0号既是空节点也是Trie树的根节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">    p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">  cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    p = son[p][u];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ol>
<li>状态表示</li>
</ol>
<p>f(i, j) 表示集合[i, j]的某一属性，例如集合中的最大值、最小值或数量</p>
<ol start="2">
<li>状态计算</li>
</ol>
<p>根据集合的划分计算</p>
<p>时间复杂度：状态数目 * 状态转移方式</p>
<p>空间复杂度：子问题的个数</p>
<h5 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h5><p>N个物品，体积为V的背包，每类物品体积为$v_i$，价值权重为$w_i$，求满足体积限制的背包的最大价值</p>
<h6 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h6><p>每类物品只能用一次</p>
<p>状态f(i, j) 表示从前i类物品中选，所选物品体积小于j的所有选法的集合中 价值最大选法的价值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f[0][0-V] = 0</span><br><span class="line">for (int i = 1; i &lt;= n; i++) </span><br><span class="line">	for (int j = 0; j &lt;= m; j++) &#123;</span><br><span class="line">		f[i][j] = f[i-1][j];</span><br><span class="line">		if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">// 滚动数组优化，因为f中i只用到i-1且j只用到左侧j和j-v[i]，因此可用一维数组从大到小滚动优化</span><br><span class="line">f[0][0-V] = 0</span><br><span class="line">for (int i = 1; i &lt;= n; i++) </span><br><span class="line">	for (int j = m; j &gt;= v[i]; j--) &#123;</span><br><span class="line">		f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h6 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h6><p>每类物品可以使用无限次，与01背包的区别主要在于集合的划分变为$f[i, j] = f[i-1, j-v[i]<em>k] + k</em>w[i]$<img src="https://tva1.sinaimg.cn/large/0082zybply1gc2qahne9fj31760a0agz.jpg" alt="image"></p>
<p>因此完全背包的状态计算可以优化为$f[i, j] = max(f[i-1, j], f[i, j-v[i]] + w[i])$，优化后可以使用滚动数组进一步简化为一维，和01背包只有j的计算顺序不同</p>
<h6 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h6><p>每类物品有$s_i$个，与完全背包状态划分计算相同，只不过k由$s[i]$约束.</p>
<p>多重背包的优化 </p>
<ul>
<li><p>二进制拆分优化 </p>
<p>由 $O(NS)$优化至$O(N\lg S)$</p>
</li>
</ul>
<h6 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h6><p>每组物品只能选一个，状态f(i, j)的划分根据第i组物品选第k个来拆分计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// f[i][j] = max(f[i-1][j], f[i-1][j - v[i][k]] + w[i][k])k</span><br></pre></td></tr></table></figure>
<h5 id="计数DP"><a href="#计数DP" class="headerlink" title="计数DP"></a>计数DP</h5><p>方案数类初始化通常为f[0] = 1，因为空集也可以看作一种划分方案</p>
<h6 id="整数划分方案数"><a href="#整数划分方案数" class="headerlink" title="整数划分方案数"></a>整数划分方案数</h6><p>求1到n中任意个数之和为x的方案数</p>
<ol>
<li>转换为完全背包问题，状态f(i, j)表示为从1-i个数中选择（每个数可选无数次）使得和恰好为j的方案数</li>
</ol>
<p>状态计算<code>f[i][j] = f[i-1][j] + f[i-1, j-i] + f[i-1][j-2*i] +...</code></p>
<p><code>f[i][j] = f[i - 1][j] + f[i, j - i]</code></p>
<ol start="2">
<li>状态f(i, j)表示所有总和为i恰好表示为j个数之和的方案数，状态计算根据j个数的最小值是否为1划分，对于最小值为1的情况，可以由去掉1的状态f(i - 1, j - 1)转移而来；对于最小值大于1的情况，可以由每个数减去1的状态f(i - j, j)转移而来</li>
</ol>
<p><code>f[i][j] = f[i-1, j-1] + f[i - j][j]</code></p>
<h5 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h5><p>递推顺序是线性序列</p>
<h6 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h6><p>状态f(i, j) 表示从起点走到(i, j)的所有路径的集合</p>
<p>注意 i 表示水平方向，j表示左下倾斜方向，初始化时需要注意<code>f[i][j+1]</code>右哨兵也会被用到</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// f[i][j] = max(f[i-1][j-1], f[i-1][j]) + a[i][j]</span><br></pre></td></tr></table></figure>
<h6 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h6><p>状态f(i) 表示以i结尾的所有上升子序列的集合</p>
<p>状态划分根据上一个数位置分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i] = max(f[j] + 1), j = 0, 1, 2,...,i-1 &amp;&amp; a[j] &lt; a[i]</span><br></pre></td></tr></table></figure>
<p>// TODO  优化</p>
<p>状态f(i)表示长度为i+1的上升子序列中末尾元素的最小值</p>
<p>由$O(n^2)$优化为$O(n\lg n)$</p>
<h6 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h6><p>f(i, j) 表示s1[1..i]和s2[1..j]的所有公共子序列</p>
<p>状态划分根据s1[i]和s2[j]是否包含在子序列中分为四类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i, j] = max(f[i-1][j], f[i][j-1], f[i-1][j-1] + 1, f[i-1][j-1]);</span><br></pre></td></tr></table></figure>
<h6 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h6><p>注意编辑距离的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt;= p; i++) f[i][0] = i;</span><br><span class="line">for (int j = 0; j &lt;= q; j++) f[0][j] = j;</span><br><span class="line">for (int i = 1; i &lt;= p; i++) </span><br><span class="line">    for (int j = 1; j &lt;= q; j++) &#123;</span><br><span class="line">        f[i][j] = min(f[i-1][j], f[i][j-1]) + 1;</span><br><span class="line">        if (s1[i-1] == s2[j-1]) </span><br><span class="line">            f[i][j] = min(f[i][j], f[i-1][j-1]);</span><br><span class="line">        else </span><br><span class="line">            f[i][j] = min(f[i][j], f[i-1][j-1] + 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h5><p>状态表示某区间，递推通常先循环区间长度，再循环区间左起点</p>
<h6 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h6><p>状态f(i, j)表示将第 i 堆到第 j 堆合并的所有合并方式中代价的最小值，因此每个区间的状态初始化为正无穷</p>
<p>状态划分根据最后一次合并的分界线的位置分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int len = 2; len &lt;= n; len++) </span><br><span class="line">    for (int i = 1; i + len - 1 &lt;= n; i++) &#123;</span><br><span class="line">        int l = i, r = i + len - 1;</span><br><span class="line">        f[l][r] = 2e8;</span><br><span class="line">        for (int k = l; k &lt; r; k++) &#123;</span><br><span class="line">            int t = f[l][k] + f[k+1][r] + a[r] - a[l-1];</span><br><span class="line">            f[l][r] = min(f[l][r], t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="能量项链"><a href="#能量项链" class="headerlink" title="能量项链"></a>能量项链</h6><h6 id="凸多边形的划分方案"><a href="#凸多边形的划分方案" class="headerlink" title="凸多边形的划分方案"></a>凸多边形的划分方案</h6><p>状态划分：根据[L, R]边所属的三角形的另一个顶点位置来划分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int len = 3; len &lt;= n + 1; len ++ )</span><br><span class="line">        for (int l = 1; l + len - 1 &lt;= n * 2; l ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            int r = l + len - 1;</span><br><span class="line">            for (int k = l + 1; k &lt; r; k ++ )</span><br><span class="line">                f[l][r] = max(f[l][r], f[l][k] + f[k][r] + w[l] * w[k] * w[r]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h5><p>数位DP通常用于解决两个整数a，b之间存在多少满足某个条件的数（且条件与数字每一位有关）的问题。<br>假设给定数x，包含n位，表示为$t_nt_{n-1}…t_1$，那么当我们求解n位数字$t_nt_{n-1}…t_1$的状态所对应的答案时就需重复计算n-1位数字$t_{n-1}t_{n-2}…t_1$的状态所对应的答案，因此具有重复子问题。<br>考虑DP状态为dp(idx, tight, sum)</p>
<h6 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h6><p>给定两个整数 a 和 b，求 a 和 b 之间的所有数字中x的出现次数，x属于0到9</p>
<p>count(int n, int x) 假设一个数为abcdefg，对1 &lt;= pppxqqq &lt;= abcdefg分类讨论：</p>
<ul>
<li><p>如果ppp = 000 到 abc-1:</p>
<ul>
<li>如果x不为0, qqq可以取000到999, cnt = abc * 1000</li>
<li>如果x为0, qqq可以取000到999, 但由于x为0,ppp不能为0只能从001到abc-1, cnt = (abc-1)* 1000</li>
</ul>
</li>
<li><p>如果ppp = abc :</p>
<ul>
<li>d &lt; x, cnt = 0</li>
<li>d = x, qqq可以取000到efg, cnt = efg + 1</li>
<li>d &gt; x, qqq可以取000到999, cnt = 1000</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">int getNum(vector&lt;int&gt; &amp;nums, int l, int r) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = l; i &gt;= r; i--) &#123;</span><br><span class="line">        res = res * 10 + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int power10(int x) &#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while (x--) &#123;</span><br><span class="line">        res *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int count (int n, int x) &#123;</span><br><span class="line">    if (!n) return 0;</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    do &#123;</span><br><span class="line">        nums.push_back(n % 10);</span><br><span class="line">        n /= 10;</span><br><span class="line">    &#125; while(n);</span><br><span class="line">    n = nums.size();</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = n - 1 - !x; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (i &lt; n - 1) &#123;</span><br><span class="line">            res += getNum(nums, n-1, i+1) * power10(i);</span><br><span class="line">            if (!x) res -= power10(i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[i] &gt; x) res += power10(i);</span><br><span class="line">        if (nums[i] == x) res += getNum(nums, i-1, 0) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    while (cin &gt;&gt; a &gt;&gt; b &amp;&amp; (a || b)) &#123;</span><br><span class="line">        if (a &gt; b) swap(a, b);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            cout &lt;&lt; count(b, i) - count(a-1, i) &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="状态DP"><a href="#状态DP" class="headerlink" title="状态DP"></a>状态DP</h5><p>状态DP的初始化通常将不合法状态的f值初始化为正无穷或负无穷</p>
<h6 id="不能打劫相邻位置的偷盗最大值"><a href="#不能打劫相邻位置的偷盗最大值" class="headerlink" title="不能打劫相邻位置的偷盗最大值"></a>不能打劫相邻位置的偷盗最大值</h6><p>状态<code>f[i]</code>表示打劫第i家的最大值</p>
<p><code>f[i] = max(f[i-1], f[i-2] + a[i])</code></p>
<p>状态<code>f[i]</code>拆分为两个状态，<code>f[i][0]</code>表示打劫至第i家且不选当前位置，<code>f[i][1]</code>表示打劫至第i家且选当前位置，状态机的边表示从当前i转移到i+1的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100001;</span><br><span class="line">int a[N], f[N][2];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n; </span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        f[0][0] = 0;</span><br><span class="line">        f[0][1] = a[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            f[i][0] = max(f[i-1][1], f[i-1][0]);</span><br><span class="line">            f[i][1] = f[i-1][0] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; max(f[n-1][0], f[n-1][1]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="股票买卖"><a href="#股票买卖" class="headerlink" title="股票买卖"></a>股票买卖</h6><p>只能买卖一次 记录最小值和最大差值</p>
<p>无限次买卖 贪心交易所有上涨交易</p>
<p>最多进行k次交易</p>
<p>手中持有股票状态为1，未持有股票状态为0</p>
<p>f[i, j, 0]表示前i天已经进行j次交易且当前无股票</p>
<p>f[i, j, 1]表示前i天正在进行j次交易且当前有股票</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcwrtqmbcjj30g2078wgm.jpg" alt="image-20200317113704313"></p>
<p>含一天冷冻期</p>
<p>f[i, 0]表示前i天且当前有股票</p>
<p>f[i, 1]表示前i天且当前在冷冻期</p>
<p>f[i, 2]表示前i天且当前无股票且不在冷冻期</p>
<p><img src="/Users/jingy/Library/Application Support/typora-user-images/image-20200317114017754.png" alt="image-20200317114017754"></p>
<p><code>f[i][0] = max(f[i-1][0], f[i-1][2] - w[i])</code></p>
<p><code>f[i][1] = f[i-1][0] + w[i]</code></p>
<p><code>f[i][2] = max(f[i-1][1], f[i-1][2])</code></p>
<h5 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h5><p>状态表示中的某一下标表示的是由状压state表示的集合</p>
<h6 id="集合类-最短Hamilton路径"><a href="#集合类-最短Hamilton路径" class="headerlink" title="集合类 - 最短Hamilton路径"></a>集合类 - 最短Hamilton路径</h6><p>状态f(i, j)表示从0走到j，走过的点的集合是i的二进制表示的所有路径的集合的路径长度的最小值</p>
<p>状态计算根据上一点的位置是0, 1,…, n-1划分</p>
<p><code>f[i][j] = min(f[i - {j}][k] + a[k][j]), k = 0, 1, 2,...,n-1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const int N = 20, M = 1 &lt;&lt; N;</span><br><span class="line">int a[N][N], f[M][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) </span><br><span class="line">        for (int j = 0; j &lt; n; j++) </span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    memset(f, 0x3f, sizeof f);</span><br><span class="line">    f[1][0] = 0;</span><br><span class="line">    // f[i][j] 表示走过的点集合为i，走到点j的所有路径</span><br><span class="line">    // 根据上一点k的不同取法划分计算 f[i][j] = f[i - &#123;j&#125;][k] + a[k][j]</span><br><span class="line">    for (int i = 0; i &lt; (1 &lt;&lt; n); i++)</span><br><span class="line">        for (int j = 0; j &lt; n; j++) </span><br><span class="line">            // 注意判断状态的合法性</span><br><span class="line">            if (i &gt;&gt; j &amp; 1) &#123;</span><br><span class="line">                for (int k = 0; k &lt; n; k++) </span><br><span class="line">                    if (i &gt;&gt; k &amp; 1) &#123;</span><br><span class="line">                        f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + a[k][j]); </span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n-1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="棋盘类-骨牌的完美覆盖"><a href="#棋盘类-骨牌的完美覆盖" class="headerlink" title="棋盘类 - 骨牌的完美覆盖"></a>棋盘类 - 骨牌的完美覆盖</h6><p>状态f(i, j)表示第i列第j个状态，j状态位等于1表示上一列有横放格子，本列有格子捅出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">const int N = 12, M = 1 &lt;&lt; 12;</span><br><span class="line">long long f[N][M];</span><br><span class="line">bool st[M];</span><br><span class="line"></span><br><span class="line">bool check(int j, int k, int n) &#123;</span><br><span class="line">    int x = j | k;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    // 下面做法错误，因为没有考虑二进制状态表示中前导0为奇数个的情况</span><br><span class="line">    // do &#123;</span><br><span class="line">    //     if (x % 2 == 0) cnt ++;</span><br><span class="line">    //     else &#123;</span><br><span class="line">    //         if (cnt &amp; 1) return false;</span><br><span class="line">    //         cnt = 0;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     x /= 2;</span><br><span class="line">    // &#125; while(x);</span><br><span class="line">    // if (cnt &amp; 1) return false;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (x &gt;&gt; i &amp; 1) &#123;</span><br><span class="line">            if (cnt &amp; 1) return false;</span><br><span class="line">            cnt = 0;</span><br><span class="line">        &#125; else cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &amp; 1) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n || m) &#123;</span><br><span class="line">        memset(f, 0, sizeof f);</span><br><span class="line">        f[0][0] = 1;</span><br><span class="line">        </span><br><span class="line">        for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123;</span><br><span class="line">            int cnt = 0;</span><br><span class="line">            st[j] = true;</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                if (j &gt;&gt; i &amp; 1) &#123;</span><br><span class="line">                    if (cnt &amp; 1) &#123; </span><br><span class="line">                        st[j]=false; </span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt = 0;</span><br><span class="line">                &#125; else cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cnt &amp; 1) st[j] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123;</span><br><span class="line">                for (int k = 0; k &lt; (1 &lt;&lt; n); k++) &#123;</span><br><span class="line">                    // j 和 k 同一位不都为1</span><br><span class="line">                    // j 和 k 不能为连续奇数个0</span><br><span class="line">                    if (!(j &amp; k) &amp;&amp; st[j | k]) &#123;</span><br><span class="line">                        f[i][j] += f[i-1][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; f[m][0] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h5><p>没有上司的舞会</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangj96.github.io/2020/01/09/string/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jing Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/09/string/" class="post-title-link" itemprop="url">Leetcode字符串题目总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-01-09 13:13:04" itemprop="dateCreated datePublished" datetime="2020-01-09T13:13:04+08:00">2020-01-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-07 13:14:30" itemprop="dateModified" datetime="2020-06-07T13:14:30+08:00">2020-06-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">0</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jing Yang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:jingy.ella@gmail.com" title="E-Mail &rarr; mailto:jingy.ella@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jing Yang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">85k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">1:18</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=6.7.0"></script>




  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  



  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
