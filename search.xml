<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基础乐理]]></title>
    <url>%2F2024%2F04%2F05%2Fmusic-foundation%2F</url>
    <content type="text"><![CDATA[####音程 度数 C D E F G A B 计算度数左闭右闭，度数和升降无关，只看字母 半音数 一个白键一个黑键一个半音 同样左闭右闭 大度 半音数=（度数-1） 2 小度 半音数=（度数-1）2 - 1 一度 它本身 半音为0 两度 中间有黑键 2个半音 大二度，中间无黑键 1个半音 小二度 三度 中间两个黑键 4 个半音 大三度 中间只有1个黑键 3 个半音 小三度 四度 除了4-7 其他中间都是2个黑键 5个半音 纯四度 4-7 中间3个黑键 六个半音 为三全音 增四度 由于黑键数减少 大度 半音数=（度数-1） 2 - 1 小度 半音数=（度数-1）2 - 2 五度 除了 7-4 其他中间都是3个黑键 7个半音 纯五度7-4 中间2个黑键 六个半音 减五度 六度 中间4个黑键 9个半音 大六度 ​ 中间3个黑键 8个半音 小六度 七度 中间5个黑键 11个半音 大七度 中间4个黑键 10个半音 小七度 八度 一定是5个黑键 12个半音 变化音程 上述是自然音程 大音程度数不变，加一个半音=增音程，加两个半音=倍增音程 小音程度数不变，减一个半音=减音程，减两个半音=倍减音程 音程转换 音程想加等于九 大小增减互换 纯音程不变 音程协和 纯一、四、五、八度为协和音程 和弦大三和弦major 大三度+小三度 例如Cmaj（简写为CM或C）：CEG 小三和弦minor 小三度+大三度 例如Dmin：DFA 减三和弦diminished 小三度+小三度 例如Bdim：BDF 大七和弦 大三度+小三度+大三度 相当于大三和弦+大七度的音 Cmaj7 CM7：CEGB FM7 小七和弦 小三度+大三度+小三度 相当于小三和弦+小七度的音 Amin7 Am7 属七和弦 dominant 大三度+小三度+小三度 相当于大三和弦+小七度的音 Gdom7 (G7):GBDF 小大七和弦 小三度+大三度+大七度 相当于小三和弦+大七度的音 EmM7：EGBD# 如何找大/小七度的音：大七度/小七度转位+8度 感情色彩 大三和弦欢快积极 小三和弦优柔哀伤 增三减三 恐怖 C大调和弦 和弦转位 三和弦有第一转位，第二转位 七和弦有第一转位，第二转位，第三转位 五度循环圈作为音名看，间隔为纯五度 调大调 全全半全全全半 主音最稳定 1536247 CGEADFB 五度循环圈作为调号看，C大调的升/降号调 按全全半全全全半来写，ABCDEFG每个字母刚好出现一次 大小调主音和三级音是小三度 即小调 全半全全半全全 自然小调 3.6.7降半音 和声小调 在自然小调基础上 7升半音 旋律小调 音阶上行时在自然小调基础上 6.7升半音 大调的六级音为关系小调的主音 小调的三级音为关系大调的主因 例如 C大调和a小调 为关系大小调 五线谱上小调使用其关系大调的调号 五线谱休止符 音值组合 常见的伴奏和弦柱式和弦 全分解和弦 半分解和弦 常见组合 万能公式 4536251 FGEmAmDmGC 4532651]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习面试问题总结]]></title>
    <url>%2F2020%2F06%2F08%2Fdeep-learning-interview%2F</url>
    <content type="text"><![CDATA[常见面试问题Disney+Hotstar 面试复盘 字节面试复盘MLP代替点积的效果一定好？（推翻NCF的最新论文） 如何证明NN能学到特征交叉？ 特征交叉的方式有哪些？ 如何设计实验证明BN对ICS有效？ 不同场景embedding怎么保证嵌入空间一致性？ （跨场景的vid embedding的使用方式） 召回离线评估 如何设计多样性评价指标？ 召回阶段和排序阶段的样本构造差异？ 随机负采样和曝光未点击负采样哪种方式效果更好？ TF模型的上线方式（不用tf-serving） Xgb解决分类和回归问题的差异？多分类下节点的分裂方式？ 线上线下不一致问题的坑有哪些？如何解决？ 合并k个有序链表 字符串s匹配pattern串 python实现lr，kmeans 找到数组中第一个未出现的正整数 LC41 百度面试复盘推荐系统的bias有哪些？ sampling bias position bias 类似于example age， 使用「这是一种非常通用的来消除机器学习系统固有偏差的方法。另外训练和在线区别对待也非常值得借鉴，一些单侧特征，训练的时候把bias影响特征加进去，在线的时候则置0」，比如美团分享的消除广告position bias（位置给广告点击带来的偏差）也是类似的做法 曝光bias 马太效应 bias 和时长/分发量消偏平滑间的差异 Parameter Server的实现原理 分布式一致性 数据并行/模型并行 解释共轭分布 TDM召回 EE召回的abtest结果分析 ​ baseline过低，召回占比提升对应的vv和完成率 ​ 冷启动类实验设计的问题，消费相同内容池，消费侧指标持平 python实现bandit算法 FM 优化后复杂度O(KN) VS FM的训练复杂度？ ​ 训练复杂度也为O(KN) 手写一个栈，以O(1)时间维护栈中最大值 内容： 模型中台，视频内容理解，强化学习，ps架构 阿里面试复盘 阿里妈妈 x属于(0,1)均匀分布，y属于(0,1)均匀分布，max(x,y)的期望 搜索推荐 wide&amp;deep系列讲解 multi-head attention self-attention Hard-attention Soft-attention 淘宝直播 一面 最大子数组和 注意下标 二面 softmax 溢出截断， 减最大值 如何融合内容侧特征 rerank listwise 模型 算法题 ip地址匹配 数学题 100个人比99次 赢家 双栏feed流和沉浸式 特征的区别 三面 multi-task model如何同时处理分类和回归的target user embedding和其他sparse feature大小 相差较大，如何处理 快手面试复盘 用两个栈实现对队列 整数按位反转 按数组分段反转链表 python深拷贝 浅拷贝 java 重载 重写 腾讯面试复盘 wxg一面 x服从均匀分布(0,1)，y服从均匀分布(0,1)，求max(x, y)的期望 二叉树的最大路径和 wxg二面 一个从负数到0到正数的数组，求数组中不同的绝对值的个数 建堆的过程和时间复杂度 cdg一面 赛马问题 广告和推荐的区别 cdg二面 递归，括号展开 京东面试复盘 贝叶斯概率，真阳性的概率 abtest 的结果置信度 线性筛素数 微软面试复盘 第一场 序列化二叉树并恢复 第二场 二维矩阵和 过拟合/欠拟合过拟合的表现： 看loss train loss 不断下降，test loss不断下降，说明网络仍在学习; train loss 不断下降，test loss趋于不变，说明网络过拟合; train loss 趋于不变，test loss不断下降，说明数据集100%有问题; train loss 趋于不变，test loss趋于不变，说明学习遇到瓶颈，需要减小学习率或批量数目; train loss 不断上升，test loss不断上升，说明网络结构设计不当，训练超参数设置不当，数据集经过清洗等问题 过拟合的解决方法： 降低模型复杂度，例如神经网络：减少网络层、神经元个数决策树；降低树的深度、剪枝 权值约束，增加正则化项，L1稀疏，L2权重衰减 Batch Normalization landscape平滑，x归一化到0附近，更容易被激活 early stop 避免权重一直更新 dropout（dropout会导致输出结果随机，因此在测试时，根据概率计算的平均结果我们需要将激活函数乘以dropping概率，通常为0.5 进行伸缩作为最终结果，或在训练时的dropout mask步骤直接除以dropping概率） 使用ReLU激活函数替代Sigmoid，ReLU具备稀疏激活性，负半区梯度变为0 数据增强 集成学习 梯度爆炸的解决方法（w&gt;1不断累积） 梯度裁剪 clip gradient 模型结构 resnet、lstm遗忘门 BN 使x的期望在0附近 参数的初始化 针对ReLU激活函数的神经元，其权重初始化通常使用随机数并使用$sqrt(2.0/n)$来平衡方差[^weightInit]，而bias通常直接初始化为零 梯度消失（w&lt;1不断累积） 激活函数使用ReLU替代Sigmoid，ReLU的梯度x&gt;0始终为1，但x&lt;0时梯度为0神经元死亡，一定程度上可以调小学习率解决 ReLU取代Sigmoid的优点避免梯度弥散 ReLU 的求导不涉及浮点运算，加速计算 负半区的输出为 0，稀疏激活，减少过拟合 Maxout$f(x)=max(w_1^Tx+b_1, w_2^Tx + b_2)$ReLU和Leaky ReLU都是这一函数的特例，例如ReLU对应w1,b1=0。 正则化范数L0 非0个数 L1 距离的度量 无穷范数 x或y的最大值 BN优化算法 一阶方法梯度下降 二阶方法Hessian 矩阵，计算Hessian矩阵可以反映坡度的陡缓牛顿法 用Hessian矩阵替代学习率-&gt;自适应但计算量太大-&gt;近似算法 共轭牛顿法 伪牛顿法 随机梯度下降（SGD）的“随机”性体现SGD使用整个数据集的子集（mini-batch SGD）而不是完整的数据集迭代估计优化的最佳方向，因为整个数据集可能非常大，因而是随机的梯度下降并不能保证每一步都是最优方向。除SGD算法外，现在已有更多改进方案可用于计算权重的变化值进行权重优化，我们将在“优化方法”一节中进一步介绍。 SGD改进动量：跳出局部最小值和鞍点；解决poor conditioning（当损失函数在一个方向上改变很快而在另一方向改变很慢，使用普通SGD会出现在变化敏感方向上的锯齿跳动，这种情况在高维下很常见。动量项将先前权重更新的一小部分添加到当前权重更新中。如果两次更新在同一方向则会加快收敛，而更新在不同方向上时则会平滑方差，从而能够尽快结束这种情况下的曲折前进Zigzagging） 自适应学习方法 Adagrad: 记录所有梯度的平方和，使得能够在较缓的维度上除以一个较小值进行加速而在较陡的维度上除以一个较大值从而减速。但由于梯度的平方和越来越大，步幅会越来越小，可能会停在鞍点处无法出来，因而Adagrad只适用于卷积层的学习。 RMSprop: RMSprop在Adagrad基础上进行小幅改动，对梯度的平方和进行衰减，衰减率（decay rate）通常设为0.9或0.99。实现了指数移动平均，类似于lstm的遗忘门。 Adam综合上述两种方法和动量 XGB并行化的实现：特征值预排序 参数调优： 正则项 gamma调叶子结点个数，lambda调叶子结点取值的L2模平方 early_stopping shrinkage，学习率控制拟合速度，单步生成树的权重 列采样，同随机森林 XGB VS GBDT 一阶 -&gt; 二阶泰勒展开 为什么使用二阶泰勒展开 使用二阶泰勒展开是为了xgboost能够自定义loss function，只要这个损失函数可以求二阶导 特征预排序 稀疏感知：将缺失值归为一个分支 直方图 LGB VS XGB leaf-wise VS level-wise level-wise方便并行计算每一层的分裂节点，提高了训练速度，但同时也因为每一level中增益较小的节点分裂增加了很多不必要的分裂；leaf-wise每次分裂增益最大的叶子节点，但容易过拟合，需要控制好depth 直方图+GOSS （Gradient-based One-Side Sampling）单边梯度抽样算法 对梯度较小的样本随机抽样，保留梯度较大的样本 直方图加速 叶节点的直方图可以通过父节点的直方图与兄弟节点的直方图相减的方式构建 https://cloud.tencent.com/developer/article/1534903 CAT VS XGB target statistic ROC AUC横坐标假阳性率，纵坐标真阳性率 统计正样本P、负样本N个数，横坐标划分1/N，纵坐标划分1/P，然后从原点出发正样本向上，负样本向右 卷积尺寸计算：输出维度公式 (n + 2p - f) / s + 1 采用same padding填充行数为 f - n % s 参数数量：filter_size filter_size out_channel + out_channel(每个out_channel对应一个偏置量)]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Embedding在推荐系统中的应用]]></title>
    <url>%2F2020%2F06%2F05%2Fembedding-recsys%2F</url>
    <content type="text"><![CDATA[Embedding在推荐系统中的应用 https://mp.weixin.qq.com/s/8Mx8CznNBlJ6adlwXbcHXQ embedding相当于one hot的平滑，one hot相当于embedding的max-pooling embedding通常取神经网络倒数第二层的参数权重 embedding向量单独训练还是端到端训练？ 单独训练的embedding训练样本大，参数学习充分； 端到端训练的embedding参数多，收敛速度慢，数据量少较难充分训练 embedding 静态表征 word2vec, fasttext, glove embedding 动态表征 elmo 双向LSTM抽取特征 gpt 单向语言模型，transformer抽取特征，输入输出attention，不受长度限制易并行 bert 双向语言模型，transformer抽取特征，其他同上 i2i召回 tag2vec, 取文章的tag的fasttext生成的embeding等权重相加，faiss取相似，按相似度截断再利用热度，ctr等加权排序 item2vec，取文章id向量，取文章作者向量 loc2vec，地名对应向量 title2vec，lstm训练标题向量 doc2vec，bert计算文章文本向量 entity2vec，tranE生成实体向量 u2i召回 user2vec 用户tag向量和文章tag向量（多个tag的向量进行加权和，归一化） 对所有用户向量进行minibatch-kmeans聚为400簇（5k users per），簇内计算相似用户，写入天级redis，相似用户topn文章候选集去重计算相似度得分，根据相似度，热度，新鲜度，质量分，ctr加权形成倒排，写入天级redis DSSM crossTag，用户tag按类别统计，每个类别取k个tag，m组tag分别和用户tag向量计算相似度 分群召回 簇召回：所有用户的tag向量或用户行为lstm向量用聚类算法（如minibatch-kmeans）聚成若干个簇（比如500个，根据肘点法确定），然后簇内做实时CF 增量聚类，一段时间内保持聚类中心不变，新增数据点选择现有最近距离中心，业务低峰时期全量更新聚类中心 动态规则聚类，选择用户画像兴趣点组合作为兴趣标签，保留用户数超过阈值的兴趣标签作为聚类中心 RFM模型用户分群 多用户融合作为群画像 Embedding的问题和优化 总结]]></content>
      <categories>
        <category>RecSys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[推荐系统召回算法总结]]></title>
    <url>%2F2020%2F05%2F28%2Fmatch-recsys%2F</url>
    <content type="text"><![CDATA[通用召回（非个性化）全局热门召回 热门即以全局后验统计概率估计用户点击的概率 热点事件bert召回 实时爬取新闻话题并对其进行bert向量预存，使用DBSCAN进行密度聚类，每个聚类中心作为事件向量根据热度时间等计算热度值；在item的bert向量中检索相似向量召回 CB召回(content-based)属性标签召回tag、cate倒排 倒排优化： 问题：1. 点击率倒排，头部标题党；完成率倒排，头部短视频 2.后验指标置信度 3.倒排的优化目标与线上目标不一致，例如离线统计窗口的后验值和线上排序的状态并不契合，新的内容很难进入倒排的头部等 解决方案： 1.资源的后验分布与资源本身的类型有关，因此将视频根据时长和类别组合分桶，在桶内做z–score归一化，将完成率的分布收缩到准正态分布 2.置信阈值的判定 1）用分发趋势预估阈值的值-&gt;直接预估完成率，facebook热度预估模型 2）优化方差，在视频分发曲线上确定阈值点A，并在阈值点后取B点计算两点差值，累计所有人的差值和，求出总和最小的点作为阈值点 或CTR平滑，解决曝光量小导致的ctr置信度低的问题 1）手工平滑 将曝光分段，每段取24小时内的数据min-max归一化 2）指数平滑 $I_j = I_j, j =1$ $I_j = \beta I_j + (1 - \beta)I_{j-1}, j &gt; 1$ $I_N = \beta I_N + (1 - \beta) I_{N-1} = \beta I_N + \beta(1-\beta)I_{N-1} + … + \beta(1-\beta)^j I_{N-j} + … + \beta(1-\beta)^{N-1}I_1$ 对曝光&lt;1000的数据不召回 3）Wilson平滑 一般效果最好 4）贝叶斯平滑 $ctr = (C_i + \alpha) / (I_i + \alpha + \beta) $ $\alpha$和$\beta$采用矩估计 总体而言，随着曝光次数的增加，对应的点击率是下降的，因此点击率需要考虑分发带来的衰减；不同类目下点击的行为也应有不同的权重，小众类目的点击比大众类目更有意义，tfidf；时间衰减可以修正处在置信阈值边界的兴趣点，即着时间推移没有新增兴趣表达的误判行为会逐渐衰减到阈值以下；对某一类目连续发生大量展现未点击的行为需要对其权重作降权。 3.倒排的优化 - 从统计到函数的趋势 使用视频信息构建模型，以倒排的目标（实际的完成率/点击率作为优化目标，以及时拟合线上的状况同时增加一定的泛化能力 聚焦置信点击率的后验值能够最大化提升推荐效果 触发tag、cate的优化： 用户不同的互动行为差异化权重 多term召回/多维度： 考虑内容的多维度属性，例如将内容的多个tag综合推荐而不是针对每个tag单独做倒排，即将用户的tag标签和内容的tag标签构造为sentence进行训练。 序列建模同时又会引入不同行为的序列权重的差异-&gt;更改word2vec的label生成逻辑和样本构造 word2vec优化增量skip-gram 负采样 基于内容的MF召回基于内容的MF召回是通过评分矩阵经过矩阵分解和最小化目标函数学习得到用户和item的向量（对比：传统基于行为过滤的协同过滤方法是基于共现矩阵） CF召回（协同过滤）Memory-based CFItem-based CF 划分窗口利用用户的点击历史，以窗口内内容id出现的条件概率作为后验预估 问题： 热点视频和大多数视频的共现概率都很高 解决：基于共现统计的cf在分母上乘视频的分发量抵消降权；item2vec本身集成word2vec高频负采样，这和数据的整体分布相关，如果参数设置不合理，分布和参数空间不match会折损训练效果；还有完成率建模带来的时长的bias，通常需要时长调权，归一化等 User-based CF 用户的相似度度量 如何加权u和u共同商品的小众属性？ jaccard对大数据量而言计算困难-&gt;simHash 用户list2list建模，利用孪生网络（适合稀疏分类问题）以用户是否为同一个用户作为label提供监督，在线召回使用bagging，不同用户间的差异化权重可以利用attention机制等学习。 Model-based CF基于MF、SVD、pLSA、LDA的CF U2U2I存在未曝光的商品，针对(u, i)矩阵中未曝光补0，然后svd分解，低秩重构仅保留主成分得到R’ 类似于SVD分解得到的两个稠密矩阵，将其参数初始化，根据下面优化目标进行学习： 最小化dist（R， R’) 使得rank（R’） &lt;= K 例如，负采样的MSE loss为：$L= -\Sigma_{(u, i \in \Omega)} \frac{1}{2}(R_{iu} - R_{ui}^{‘})$ 用户向量和物品向量内积为1 是否等价于空间上距离的相似性？ 满足低秩条件下才满足！ 模型学习的未曝光内容的相似性和其被负采样的label相互制约，抗噪 DSSM/DeepCF/MatchNetDSSM双塔，用户点击做正样本，全局随机采样负样本 如果使用展现未点击作负样本，召回结果会偏向热门 这样采样的方式，最终的结果，就是boost 高热，也就是实际更好（假设系统没有问题）的候选，会放大预估分，实际差一些的候选，会缩小预估分，最终有一定的概率能取到最优； 召回和排序阶段选取样本的差异 DSSM优化 user和item特征交叉 uid的embedding直接连到瓶颈层把doc向量作增维，强化uid记忆性。为什么不连vid特征？ 增加attention、FM等结构增强模型表达能力，增加side-info 在user侧增加attention，学习用户session内不同类型行为的权重 在item侧增加side info以强化长尾item特征缓解高热和attention，学习不同side info属性信息的主次 融合FM特征 pair-wise双塔提升模型预测能力 multi-view DSSM 结合多业务信息丰富用户表达 多塔多目标，结合多业务指标 CF的问题： Icf时效性，新视频不容易出，即i2i 如果使用共现概率会存在新item的冷启动问题，但如果i2i基于内容本身的相似度，则可以很容易召回新的item。同理ucf会存在新用户和新item的冷启动问题。 解决方案： icf中引入泛化特征side info，利用side info的共现信息。 lookalike 用户点击的一系列视频，其中某一个新视频可以通过邻近点击视频向量加权平均近似求得 EGES在行为向量基础上增加side info构成语义行为向量，以解决用户行为数量少的item的冷启动 用concat、avg pooling、self-attention和transformer encoder的方法融合side info Base Graph Embedding（BGE） user 的行为序列构建网络结构，并将网络定义为有向有权图。其中：根据行为的时间间隔，将一个 user 的行为序列分割为多个session进行deepwalkGraph Embedding with Side Information（GES）该方案增加 item 的额外信息（例如category, brand, price等）丰富 item 表征力度。根据 EGES的算法框架可知：（1）item 和 side information（例如category, brand, price等） 的 Embedding 是通过 word2vec 算法一起训练得到的。如果分开训练，得到的item_embedding和category_embedding（brand_embedding， price_embedding）不在一个向量空间中，做运算无意义。即：通过 DeepWalk 方案得到 item 的游走序列，同时得到对应的category（brand, price）序列。然后将所有序列数据放到word2vec模型中进行训练。（2）针对每个 item，将得到：item_embedding，category_embedding，brand_embedding，price_embedding 等 embedding 信息。将这些 embedding 信息求均值来表示该 itemEnhanced Graph Embedding with Side Information（EGES）组合表示 item_embedding 时，对 item 和 side information（例如category, brand, price等）的embedding施加不同的权重，用改进的word2vec算法（Weighted Skip-Gram）确定模型的参数。Sparse Features代表 item 和 side information 的ID信息；Dense Embeddings 表示 item 和 side information 的 embedding 信息；alpha分别代表 item 和 side information 的 embedding 权重；Sampled Softmax Classifier中的N代表采样的负样本（见论文中的Algorithm 2 Weighted Skip-Gram描述的第8行），P代表正样本（某个item周边上下n个item均为正样本，在模型中表示时不区分远近）； Youtube DNN训练集对每个用户提取等数量的训练样本，防止高度活跃用户对于loss的过度影响。测试集YouTube为什么不采用经典的随机留一法（random holdout），而是一定要把用户最近的一次观看行为作为测试集，避免引入future information，产生与事实不符的数据穿越。video embedding的时候，要直接把大量长尾的video直接用0向量代替输入处理：样本通过spark处理为tfrecord，传至ceph，输入采用Dataset多线程读取 特征处理： 多值离散特征，例如历史播放列表、搜索词表：获取每个词的embedding平均求和得到固定长度隐向量 单值离散特征，例如地理位置，获取固定长度embedding向量 单值连续特征：年龄、性别：年龄构造平方、开方项 模型结构： 将上述三类特征concat，传入三层全连接层，使用ReLU函数，输入固定维度的user向量。 损失函数： 损失函数为softmax多分类交叉熵。将一次训练样本的播放vid作为正样本，多分类问题的类目个数为vid的数量，最后一层输出的user向量和vid向量的内积加上偏置表示user对该vid的感兴趣程度$z_i = u ·I_i + b_i$，然后通过softmax函数将所有感兴趣程度转化为概率： $p_i = \frac{e^{z_i}}{\Sigma_j e^{z_j} }$，利用交叉熵得到损失函数：$L=- \Sigma_i y_i·log(p_i)$，其中$y_i$是一个vid数量维度的one-hot向量，只有被播放的视频对应一维是1，其余为0，可以采用负采样降低0的维度数量。 输出： DNN 最后一层为user的embedding表示，softmax的权重为item的embedding表示 线上serving： 使用faiss进行topk search Faiss支持l2欧式距离和IP内积的方式，但基于内积的方式需要user和item向量均是归一化向量，但youtube DNN模型训练时不进行向量的l2归一化，因此需要使用在原向量中增加一维，将内积问题转换为欧式距离问题来解决 MIP(maximum inner product)2NN(nearest neighbor)https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/XboxInnerProduct.pdf 样本不平衡问题 使用Focal Loss clip gradient 可以缓解梯度爆炸 / 防止出现网络训练中出现NaN Triplet loss通常配合OHEM(online hard example mining) 权值共享： 多个特征的同一概念embedding的look_up table共享 基于牛顿冷却定律的时间衰减 负采样 tf.sample_softmax_loss调用log_uniform_candidate_sampler负采样，数值越小被采样的概率越大，因此对于vid，按照其在所有用户播放历史中出现的次数降序排列，标号越小出现次数越大，0保留用于替换确实值。但这样也会导致头部效应。可以采用word2vec论文或源码中的高频采样公式构造样本： $ran = (\sqrt{\frac{x}{0.001}} + 1)*(0.001/x)$，使高频词被保留的概率更小。 NEG（negative）采样代替softmax，tf.nn.learned_unigram_candidate_sampler。噪声对比估计(NCE,Noise-Contrastive Estimation)，它将点击样本的softmax变为多个二分类logistic问题。由于softmax具有sum-to-one的性质，最大化点击样本的概率必然能导致最小化非点击样本的概率，而二分类logistic则没有这个性质，所以需要人为指定负样本，NCE就是一种根据热度随机选取负样本的技术，通过优化NCE损失，可以快速地训练得到模型的所有参数。在实践中，我们采用了TensorFlow提供的函数tf.nn.nce_loss去做候选采样并计算NCE损失。 user embedding和item embedding如何保证在同一个空间和dssm类似，都是通过内积限制两个embedding在相同空间，在CF中可以通过矩阵分解得到user和vedio的向量表示，这里最后的softmax相当于广义矩阵分解，模型最后一层隐层就是user embedding，通过u*v得到vedio的概率，v就是vedio embedding，只不过这里用来作为softmax层的权重；最后一层输出的user向量和vid向量的内积加上偏置表示user对该vid的感兴趣程度，然后通过softmax函数将所有感兴趣程度转化为概率 和排序模型的差异：引入另一套DNN作为ranking model的目的就是引入更多描述视频、用户以及二者之间关系的特征，例如language embedding: 用户语言的embedding和当前视频语言的embeddingtime since last watch: 自上次观看同channel视频的时间 previous impressions: 该视频已经被曝光给该用户的次数 example age，倾向于新视频，sample log距离当前时间，预测时置为0保证预测时处于训练的最后一刻此外，ranking model不采用经典的logistic regression当作输出层，而是采用了weighted logistic regression 召回的评估问题相关性高能否代表召回效果有提升？ 相关性提升到80以上后应该更关注效果 召回占比的提升 排序时这一路召回q值的提升还要关注其分布，是否均值变小方差变大，以及这路召回的uniq占比 MRR指标]]></content>
      <categories>
        <category>RecSys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[知识图谱在推荐系统的应用]]></title>
    <url>%2F2020%2F05%2F28%2Fkg-recsys%2F</url>
    <content type="text"><![CDATA[知识图谱引入推荐系统的两类方式： 基于特征的方法利用知识图谱得到实体、关系的embedding 学习方式： 分别学习 DKN（Deep Knowledge-aware Network） 首先通过实体链接将新闻标题文本中实体链接到知识图谱，获得实体的实体特征和上下文实体特征（所有一跳邻居节点的实体上下文特征的均值）。 将新闻标题词向量、实体向量、实体上下文向量作为多通道使用CNN融合得到candidate的embedding；用户历史兴趣通过attention机制结合candidate embedding学习不同的权重作为user embedding；Candidate embedding和user embedding经过concat通过mlp预测点击率。 交替学习（多任务学习） MKR（Multi-task ） 推荐网络使用user和item特征预测点击率；知识图谱网络使用三元组的头节点和关系表示作为输入预测尾节点；两者通过交叉特征共享单元链接，然后分别固定一侧网络参数交替训练。 联合学习（end2end） CKE（collaborative knowledge base embedding） 知识图谱实体表示和图像表示、文本表示三类目标函数与协同过滤结合得到联合损失函数训练 Ripple Network 以用户历史记录为中心在图谱上扩散，并在扩散过程中衰减得到item embedding和user embedding，使用联合损失函数训练 KGAT GCN建模，邻居节点使用注意力机制融合，使用联合损失函数训练 基于结构的方法利用知识图谱使用bfs、dfs得到多跳关联实体]]></content>
      <categories>
        <category>RecSys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法模版-中级篇]]></title>
    <url>%2F2020%2F02%2F03%2Falgo-template2%2F</url>
    <content type="text"><![CDATA[目录 位运算 初级数论(辗转相除/素数/快速幂) 离散化 二分判定 区间合并/区间贪心调度 前缀和/差分 树状数组 线段树 图论 字符串匹配 Trie树 高精度 位运算取最靠右的一位1123int lowbit(int x) &#123; return x &amp; -x;&#125; 二进制中1的个数1234while(x) &#123; x -= lowbit(x); res++;&#125; 获取/设置右起第k位数1234// 获取第k位n &gt;&gt; k &amp; 1// 设置第k位为1n | 1 &lt;&lt; k 初级数论辗转相除法最大公约数时间复杂度 $O(\lg max(a,b))$ 123int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125; 最大公倍数123int lcm(int a, int b) &#123; return a * b / gcd(a, b);&#125; 扩展欧几里得算法求x, y整数，使得ax + by = gcd(a, b)，时间复杂度 $O(\lg max(a,b))$ 裴蜀定理有任意正整数a, b，gcd（a，b）= d，那么对于任意的整数x，y，ax+by都一定是d的倍数，特别地，一定存在整数x，y，使ax+by=d成立。推论a,b互素的充要条件是存在整数x，y使ax+by=1 123456789int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125; 素数素数判定 / 试除法试除法实现素数判定、约数枚举、整数分解的时间复杂度均为 $O(\sqrt n)$ 1234567bool isPrime(int x) &#123; if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i++) &#123; if (x % i == 0) return false; &#125; return true;&#125; 约数枚举 12345678910vector&lt;int&gt; divisor(int x) &#123; vector&lt;int&gt; res; for (int i = 2; i &lt;= x / i; i++) &#123; if (x % i == 0) &#123; res.push_back(i); if (i != x / i) res.push_back(x / i); &#125; &#125; return res;&#125; 整数分解 1234567891011map&lt;int, int&gt; prime_factor(int x) &#123; map&lt;int, int&gt; res; for (int i = 2; i &lt;= x / i; i++) &#123; while(x % i == 0) &#123; res[i]++; x /= i; &#125; &#125; if (x != 1) res[x] = 1; return res;&#125; 素数筛法埃氏筛法 时间复杂度 $O(n \lg n lg n)$ 12345678910111213int prime[N];int st[N];int sieve(int n) &#123; int p = 0; for (int i = 2; i &lt;= n; i++) &#123; if (st[i]) continue; prime[p++] = i; for (int j = i; j &lt;= n; j += i) st[j] = true; &#125; return p;&#125; 1234567891011vector&lt;int&gt; primes;bool st[N];void get_primes(int n) &#123; for (int i = 2; i &lt;= n; i ++ ) &#123; if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] &lt;= n / i; j ++ ) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125; 快速幂求$a^k\mod p$的值，反复平方法 时间复杂度 $O(\lg k)$ 预处理出 $a^{2^0} \mod p$, $a^{2^1} \mod p$, $a^{2^2} \mod p$,…, $a^{2^{lgk}} \mod p$的值（反复平方k次），然后根据底数不变指数相加，将k拆分为若干个2的次幂之和，则可以根据k的二进制形式将预处理的值按需相乘 1234567891011typedef long long LL;ll mod_pow(ll a, ll k, ll p) &#123; ll res = 1; while (k) &#123; if (k &amp; 1) res = res * a % p; a = a * a % p; k &gt;&gt;= 1; &#125; return res;&#125; 离散化待离散值排序、去重，然后二分求离散化对应坐标 单值离散化 1234567891011121314151617vector&lt;int&gt; all;sort(all.begin(), all.end());all.erase(unique(all.begin(), all.end()), all.end());// 待离散化值y-&gt;离散化后xint x = find(all.begin(), all.end(), y) - all.begin();// orint bs(int k) &#123; int l = 0, r = all.size() - 1; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (all[mid] &gt;= k) r = mid; else l = mid + 1; &#125; return r + 1;&#125;int x = bs(y); 线段坐标离散化 每个端点需要考虑其本身和前后两点，从而将线段压缩 1234567891011121314151617181920int compress(vector&lt;int&gt; &amp;x1, vector&lt;int&gt; &amp;x2, int w) &#123; vector&lt;int&gt; all; for (int i = 0; i &lt; x1.size(); i++) &#123; for (int d = -1; d &lt;= 1; d++) &#123; int tx1 = x1[i] + d, tx2 = x2[i] + d; if (tx1 &gt;= 1 &amp;&amp; tx1 &lt;= w) all.push_back(tx1); if (tx2 &gt;= 1 &amp;&amp; tx2 &lt;= w) all.push_back(tx2); &#125; &#125; sort(all.begin(), all.end()); all.erase(unique(all.begin(), all.end()), all.end()); for (int i = 0; i &lt; x1.size(); i++) &#123; x1[i] = find(all.begin(), all.end(), x1[i]) - all.begin(); x2[i] = find(all.begin(), all.end(), x2[i]) - all.begin(); &#125; return all.size();&#125; 二分判定给定N个数，将其分为X组，每组K = N / X个数且需要保证K个数互不重复，求出每组最大数和最小数间的差值，求能够实现的所有组该差值总和的最小值 123456789101112131415161718bool check(int n, int k, vector&lt;int&gt;&amp; a, int mid) &#123; &#125;int xGroup(int n, int k, vector&lt;int&gt;&amp; a) &#123; int maxn = 0, minn = 2e9; for (int i = 0; i &lt; n; i++) &#123; minn = min(a[i], minn); maxn = max(a[i], maxn); &#125; int l = 0, r = (maxn - minn) * (n / k); while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(n, k, a, mid)) r = mid; else l = mid + 1; &#125; return l;&#125; 区间问题区间合并按区间左端点排序 12345678910111213141516171819void merge(vector&lt;PII&gt; &amp; segs) &#123; vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for(auto seg : segs) &#123; if (ed &lt; seg.first) &#123; if (st != -2e9) res.push_back(&#123;st, ed&#125;); st = seg.first; ed = seg.second; &#125; else ed = max(ed, seg.second); &#125; if (st != -2e9) &#123; res.push_back(&#123;st, ed&#125;); &#125; segs = res;&#125; 区间覆盖问题求覆盖各区间的最少点数(每个区间至少包含一个点)按区间右端点排序，选取最右点 123456789101112131415161718192021222324typedef pair&lt;int, int&gt; PII;bool cmp(const PII &amp;a, const PII &amp;b) &#123; return a.second &lt; b.second;&#125;int main() &#123; int n; cin &gt;&gt; n; int a, b; vector&lt;PII&gt; v; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; v.push_back(&#123;a, b&#125;); &#125; sort(v.begin(), v.end(), cmp); int res = 0, ed = -2e9; for (int i = 0; i &lt; n; i++) &#123; if (ed &lt; v[i].first) &#123; ed = v[i].second; res ++; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; 区间调度问题/求不相交区间的最多区间数目如果最多有x个不相交区间，那么就至少需要x个点覆盖所有区间，因为本题和上一题等价，只有区间边界可能略有不同 选取结束时间最早的活动 -&gt; 按区间右端点排序，选取max_ed和下一个区间起始不相交的位置 求按照不相交区间分组的最少分组数目按区间左端点排序，记录每个组的最右坐标，依次枚举每个区间能否加入各个组，如果不能则新开一组。实际上枚举每个区间是否有可加入的组只需要找右坐标最小的组即可。 12345678910111213141516171819202122232425#define l first#define r secondtypedef pair&lt;int, int&gt; PII;int main() &#123; int n; cin &gt;&gt; n; vector&lt;PII&gt; a(n); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; a[i] = &#123;x, y&#125;; &#125; sort(a.begin(), a.end()); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; for (int i = 0; i &lt; n; i++) &#123; if (que.empty() || a[i].l &lt;= que.top()) &#123; que.push(a[i].r); &#125; else &#123; que.pop(); que.push(a[i].r); &#125; &#125; cout &lt;&lt; que.size() &lt;&lt; endl;&#125; 求覆盖指定线段的最少区间数目按区间左端点排序，依次枚举选取满足左端点在线段左侧的右端点最大的区间 1234567891011121314151617181920212223242526272829sort(range, range + n);int res = 0;bool success = false;for (int i = 0; i &lt; n; i ++ )&#123; int j = i, r = -2e9; while (j &lt; n &amp;&amp; range[j].l &lt;= st) &#123; r = max(r, range[j].r); j ++ ; &#125; if (r &lt; st) &#123; res = -1; break; &#125; res ++ ; if (r &gt;= ed) &#123; success = true; break; &#125; st = r; i = j - 1;&#125;if (!success) res = -1;cout &lt;&lt; res &lt;&lt; endl; #####区间交集问题 两区间[x1, y1]和[x2, y2]不存在交集的条件是 y1 &lt; x2 || y2 &lt; x1，反之，则交集区间是[max(x1, x2), min(y1, y2)] 前缀和/差分一维前缀和为便于计算，下标从1开始 s[0] = a[0] = 0 s[i] = s[i-1] + a[i]; 求区间[l, r]元素和s[r] - s[l-1] 二维前缀和s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j] 求区间[(x1, y1), (x2, y2)]元素和s[x2][y2] - s[x1-1][y1] - s[x1][y1-1] + s[x1-1][y1-1] 一维差分差分可看作前缀和的逆操作，可实现$O(1)$时间的区间修改和单点修改 123456789void modify(int l, int r, int c) &#123; b[l] += c; b[r+1] -= c;&#125;// 复原原矩阵更新后的值for (int i = 1; i &lt;= n; i++) &#123; b[i] += b[i-1];&#125; 二维差分12345678910111213141516const int N = 1005; // 注意数组从1开始且设计N+1，N至少要大于等于2 int b[N][N];void modify(int x1, int y1, int x2, int y2, int c) &#123; b[x1][y1] += c; b[x2+1][y1] -= c; b[x1][y2+1] -= c; b[x2+1][y2+1] += c;&#125;// 复原原矩阵更新后的值for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]; &#125;&#125; 差分+贪心求区间内所有值通过区间加1/减1全部相等的最小变换次数 差分+前缀和满足互相看见约束的序列各位置的最高可能高度 树状数组树状数组是支持区间单点修改的前缀和 将上图所有区间从左至右按序排列，其区间长度的二进制表示为：1,10,1, 100, 1, 10, 1, 1000而图中区间标号对应的二进制表示为：1,10,11,100,101,110,111,1000用lowbit函数将区间标号映射为区间长度：区间长度即区间标号二进制表示从右往左出现第一个1以及这个1之后的那些0组成数的二进制对应的十进制的数。 区间标号映射区间长度 123int lowbit(int x) &#123; return x &amp; -x;&#125; 初始化空间$O(n)$，注意下标从1到n 单点修改操作需要更新所有包含它的区间，时间复杂度$O(log n)$ 123456int tr[N];void add(int x, int c) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;&#125; 区间查询需要查询分支包含的所有区间，时间复杂度$O(log n)$ 12345678910// a[1]...a[x]int presum(int x) &#123; int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i];&#125;// a[i]...a[j]int sum(int i, int j) return presum(j) - presum(i-1); e.x. 计算右侧小于当前元素的个数 差分+树状数组可实现区间修改、单点查询或区间修改、区间查询 二维树状数组线段树五类操作， 四倍空间，初始化复杂度$O(n)$，区间操作查询或更新复杂度均为$O(\lg n)$ pushdown操作用于区间修改时的懒标记（仅支持单点修改时不需要），在区间修改和查询需要分裂区间前调用 支持单点修改的区间最大值查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const int N = 200010;struct Node &#123; int l, r; int v;&#125;tr[N * 4];void pushup(int u) &#123; tr[u].v = max(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);&#125;void build(int u, int l, int r) &#123; tr[u] = &#123;l, r&#125;; if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); // 如果初始化时对v有修改，则需要调用pushup(u);&#125;// 单点修改void modify(int u, int x, int v) &#123; if (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (x &lt;= mid) modify(u &lt;&lt; 1, x, v); else modify(u &lt;&lt; 1 | 1, x, v); pushup(u); &#125;&#125;int query(int u, int l, int r) &#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].v; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int v = 0; // 注意递归调用的查询区间仍然是[l, r]，使用[l, mid]可以会放大空间 if (l &lt;= mid) v = query(u &lt;&lt; 1, l, r); if (r &gt; mid) v = max(v, query(u &lt;&lt; 1 | 1, l, r)); return v;&#125;int main () &#123; int m, p; cin &gt;&gt; m &gt;&gt; p; int n = 0, last = 0; build(1, 1, m); for (int i = 0; i &lt; m; i++) &#123; char op; int x; cin &gt;&gt; op &gt;&gt; x; if (op == &apos;Q&apos;) &#123; last = query(1, n-x+1, n); cout &lt;&lt; last &lt;&lt; endl; &#125; else &#123; modify(1, n+1, (x + last) % p); n++; &#125; &#125;&#125; 支持区间修改的区间和查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const int N = 100010;typedef long long ll;int a[N];struct Node &#123; int l, r; ll sum, add;&#125;tr[N * 4];void pushup(int u) &#123; tr[u].sum = tr[u&lt;&lt;1].sum + tr[u &lt;&lt; 1 | 1].sum;&#125;void pushdown(int u) &#123; auto &amp;root = tr[u], &amp;left = tr[u&lt;&lt;1], &amp;right = tr[u &lt;&lt; 1 | 1]; if (root.add) &#123; left.add += root.add; left.sum += (ll)(left.r - left.l + 1) * root.add; right.add += root.add; right.sum += (ll)(right.r - right.l + 1) * root.add; root.add = 0; &#125;&#125;void build(int u, int l, int r) &#123; if (l == r) tr[u] = &#123;l, r, a[l], 0&#125;; else &#123; tr[u] = &#123;l, r&#125;; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125;&#125;// 区间修改void modify(int u, int l, int r, int d) &#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123; tr[u].sum += (ll)(tr[u].r - tr[u].l + 1) * d; tr[u].add += d; &#125; else &#123; pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, d); if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, d); pushup(u); &#125;&#125;ll query(int u, int l, int r) &#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; ll v = 0; if (l &lt;= mid) v = query(u &lt;&lt; 1, l, r); if (r &gt; mid) v += query(u &lt;&lt; 1 | 1, l, r); return v;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) &#123; int l, r, d; char op; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == &apos;C&apos;) &#123; cin &gt;&gt; d; modify(1, l, r, d); &#125; else &#123; cout &lt;&lt; query(1, l, r) &lt;&lt; endl; &#125; &#125;&#125; 图论邻接矩阵int G [maxv][maxv]或&lt;vector&lt;vector&lt;int&gt; &gt; G 邻接表vector&lt;int&gt; G[maxv] struct edge { int to; int cost; }vector&lt;edge&gt; G[maxv] BFS/DFS搜索时间复杂度均为$O(V+ E)$ BFS优化： 多源BFS矩阵各点到多个候选起点的最短距离 可假设一虚拟源点，将其与多个起点分别相连，则转换为单源BFS的最短距离，实际实现时只需要将多个起点在第一轮都加入队列即可 双端队列BFS适用于不同边权的情况 BFS优化双向广搜 A* 染色法判定二分图1234567891011121314151617181920212223vector&lt;int&gt; G[maxv];int color[maxv];int V;bool dfs(int v, int c) &#123; color[v] = c; for (int i = 0; i &lt; G[v].size(); i++) &#123; if (color[G[v][i]] == c) return false; if (color[G[v][i] == 0 &amp;&amp; !dfs(G[v][i], -c)) return false; &#125; return true;&#125;bool check() &#123; bool flag = true; for (int i = 0; i &lt; V; i++) if (color[i] == 0) if (!dfs(i, 1)) &#123; flag = false; break; &#125; return flag;&#125; 拓扑排序拓扑图（可以拓扑排序的图） 等价于有向无环图DAG 将入度为0点入队，出队去边减去相关入度将入度为0点入队，队列元素即拓扑序，队列元素小于顶点数说明可能存在重边和自环，拓扑序列不存在 $O(V+E)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243const int N = 100001;vector&lt;int&gt; G[N];int d[N]; // 入度数int n, m;// 使用stl queue元素会pop出队需要另开数组单独记录结果或者直接使用数组模拟队列vector&lt;int&gt; res; bool topsort() &#123; queue&lt;int&gt; q; // 如果最终拓扑序需要按字典序输出，则将队列改为小根堆 for (int i = 1; i &lt;= n; i++) if (!d[i]) &#123; q.push(i); res.push_back(i); &#125; while (q.size()) &#123; int t = q.front(); q.pop(); for (int i = 0; i &lt; G[t].size(); i++) if (--d[G[t][i]] == 0) &#123; q.push(G[t][i]); res.push_back(G[t][i]); &#125; &#125; return res.size() == n;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); d[b]++; &#125; if (!topsort()) cout &lt;&lt; -1 &lt;&lt; endl; else &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125;&#125; 最短路问题Bellman-Ford 允许负环每条边松弛|V| -1次（最坏情况下每次循环只松弛了一条边）之后如果存在不满足三角不等式的结点v.d &gt; u.d + w(u,v)说明存在负权重环 时间复杂度$O(VE)$ 优化 - 拓扑排序后按序松弛 Dijkstra 不许负权重边维护一个已求出最短路径节点的集合S，以v.d为key构造最小堆，每次选择V-S中的最小堆顶，将其加入S并松弛所有与其相邻的边。注意第一次执行循环extract-min得到的是源点s 优先队列实现时间复杂度$O(VE)$ Floyd 适用负权重边，不允许存在负权重环 时间复杂度$O(V^3)$ 最小生成树Kruskal算法：集合A是森林，按权重从低到高考察每条边，如果它将两棵不同的树连接起来就加入到森林A里并完成两棵树的合并 Prim算法：集合A是一棵树，每次加入连接集合A和A之外结点的所有边中权重最小的边 用并查集和优先队列分别实现，时间复杂度均为$O(ElgV)$ 字符串匹配暴力时间复杂度$O(n-m+1)*m$ 123456789for (int i = 1; i &lt;= (n - m + 1); i++) &#123; bool flag = true; for (int j = 1; j &lt;= m; j++) if (s[i + j - 1] != p[j]) &#123; flag = false; break; &#125;&#125;return flag; KMP前缀函数 $\pi[q]$是能构成$P_q (即P[1…q])$真后缀的P的最长前缀长度$\pi[q] = max(k : k &lt; q 且 P_k \sqsupset P_q)$ next[i]表示以p[i]结尾的p的子串的前缀函数值，即next[i] = j 表示 p[1…j] == p[i - j + 1…i] 预处理阶段摊还分析，时间复杂度$\Theta(m)$，因为j最多++ m次，因此while循环最多执行m次，同理匹配阶段时间复杂度$\Theta(n)$ 字符串下标从1开始，next[1] = 0 1234567891011121314151617181920212223// 待匹配串s，模式串p，下标从1开始int n+1 = s.size();int m+1 = p.size();// 求next数组, next[1] = 0for (int i = 2, j = 0; i &lt;= m; i++) &#123; while(j &amp;&amp; p[i] != p[j+1]) j = ne[j]; if (p[i] == p[j+1]) j++; ne[i] = j;&#125;// kmp匹配for (int i = 1, j = 0; i &lt;= n; i++) &#123; // j表示当前模版串下一个要匹配位置的前一位 // j == 0 表示j退回到起点 // 如果j下一个位置不能匹配，则匹配串需要后移j-next[j]步，新的匹配末端位置即j-(j-next[j]) while(j &amp;&amp; s[i] != p[j+1]) j = ne[j]; if (s[i] == p[j+1]) j++; if (j == m) &#123; j = ne[j]; // 匹配成功后的逻辑 //e.x. cout &lt;&lt; i - m &lt;&lt; endl; &#125;&#125; 字符串下标从0开始，next[0] = -1 1234567891011121314ne[0] = -1;for (int i = 1, j = -1; i &lt; m; i ++ )&#123; while (j &gt;= 0 &amp;&amp; p[j + 1] != p[i]) j = ne[j]; if (p[j + 1] == p[i]) j ++ ; ne[i] = j;&#125;for (int i = 0, j = -1; i &lt; n; i ++ )&#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m - 1) cout &lt;&lt; i - j &lt;&lt; &apos; &apos;;&#125; Trie 树高效存储和查询字符串的集合 插入和查询时间复杂度$O(\log n)$，时间复杂度$O(n^2)$ 12345678910111213141516171819202122232425const int N = 100010;int son[N][26]; // Trie树每个节点的字节点，此处英文字母只包含26个小写字母int cnt[N];// 以当前这个点结尾的单词数量int idx; // 表示层数下标，0号既是空节点也是Trie树的根节点void insert(string str) &#123; int p = 0; for (int i = 0; i &lt; str.size(); i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; &#125; cnt[p] ++;&#125;int query(string str) &#123; int p = 0; for (int i = 0; i &lt; str.size(); i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p];&#125; 高精度高精度加法数据范围为数字位数而非数字本身，使用string读入，vector逆序存储便于进位 123456789101112131415161718192021222324252627282930vector&lt;int&gt; add(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) &#123; if (a.size() &lt; b.size()) return add(b, a); int t = 0; vector&lt;int&gt; c; for (int i = 0; i &lt; a.size(); i++) &#123; t += a[i]; if (i &lt; b.size()) t += b[i]; c.push_back(t % 10); t /= 10; &#125; if (t) c.push_back(t); return c;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; vector&lt;int&gt; B; for (int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &apos;0&apos;); for (int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - &apos;0&apos;); vector&lt;int&gt; C = add(A, B); reverse(C.begin(), C.end()); for (int i = 0; i &lt; C.size(); i++) &#123; cout &lt;&lt; C[i]; &#125; cout &lt;&lt; endl;&#125; 高精度减法负号的判定 cmp函数：依次判断长度和各个位置的数 减法进位的处理 123c.push_back((t + 10) % 10);if (t &lt; 0) t = 1;else t = 0; 先导0的去除，注意最后结果是0要保留一位0 while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546bool cmp(vector&lt;int&gt; &amp; a, vector&lt;int&gt; &amp; b) &#123; if (a.size() != b.size()) return a.size() &gt; b.size(); for (int i = a.size() - 1; i &gt;= 0; i--) &#123; if (a[i] != b[i]) return a[i] &gt; b[i]; &#125; return true;&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) &#123; int t = 0; vector&lt;int&gt; c; for (int i = 0; i &lt; a.size(); i++) &#123; t = a[i] - t; if (i &lt; b.size()) t -= b[i]; c.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); return c;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; vector&lt;int&gt; B; vector&lt;int&gt; C; for (int i = a.size() - 1; i &gt;= 0; i--) &#123; A.push_back(a[i] - &apos;0&apos;); &#125; for (int i = b.size() - 1; i &gt;= 0; i--) &#123; B.push_back(b[i] - &apos;0&apos;); &#125; if (cmp(A, B)) C = sub(A, B); else &#123; C = sub(B, A); cout &lt;&lt; &quot;-&quot;; &#125; for (int i = C.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; C[i]; &#125; cout &lt;&lt; endl;&#125; 高精度乘法高精度乘整数 12345678910vector&lt;int&gt; mul(vector&lt;int&gt; &amp;a, int b) &#123; vector&lt;int&gt; c; int t = 0; for (int i = 0; i &lt; a.size() || t; i++) &#123; if (i &lt; a.size()) t += a[i] * b; c.push_back(t % 10); t /= 10; &#125; return c;&#125; 高精度乘高精度 123456789101112131415161718vector&lt;int&gt; mul(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) &#123; vector&lt;int&gt; res(alen + blen, 0); // i*j存放i+j for (int i = 0; i &lt; alen; i++) &#123; for (int j = 0; j &lt; blen; j++) &#123; res[i + j] += a[i] * b[j]; &#125; &#125; int t = 0; for (int i = 0; i &lt; (int)res.size(); i++) &#123; t += res[i]; res[i] = t % BASE; t /= BASE; &#125; while (res.size() &gt; 1 &amp;&amp; res.back() == 0) &#123; res.pop_back(); &#125;&#125; 高精度除法高精度除整数 123456789101112vector&lt;int&gt; div(vector&lt;int&gt; &amp;a, int b, int &amp;r) &#123; vector&lt;int&gt; c; r = 0; for (int i = a.size() - 1; i &gt;= 0; i--) &#123; r = r * 10 + a[i]; c.push_back(r / b); r %= b; &#125; reverse(c.begin(), c.end()); while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); return c;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法模版-初级篇]]></title>
    <url>%2F2019%2F12%2F31%2Falgo-template1%2F</url>
    <content type="text"><![CDATA[目录 二分 双指针 单调队列 滑动窗口 哈希 单调栈 二叉树 快速排序/快速选择 堆/优先队列 归并排序 回溯/递归/DFS BFS 图 并查集 动态规划 贪心 数组trick ​ 二分二分本质不是单调性，只需要区间针对某个性质能够分成两段，一段满足一段不满足即可。 找到能够划分区间左右两半的性质，如果if (check(mid)) 条件成立，判断答案在左区间还是右区间，如果答案在左区间并且mid也可能是答案，按模板1来划分；如果答案在右区间并且mid也可能是答案，按模板2来划分（）。 模板1mid使用下中位数，模板2使用下中位数+1，终结条件为$low==high$，注意区间左右均为闭区间 版本1最大值最小问题，第一个&gt;=target的元素，满足check条件的区间左边界区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用，其更新操作是r = mid或者l = mid + 1。计算mid时不需要加1。 123456789101112int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; // 两个int相加减会溢出 中间加个长整型常量 int mid = l + 0ll + r &gt;&gt; 1; // 第一个大于等于key的数 if (a[mid] &gt;= key) if (check(mid)) r = mid; else l = mid + 1; &#125; return l;&#125; 版本2最小值最大问题，最后一个&lt;= target的元素，找满足check条件的区间右边界区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用，其更新操作是r = mid - 1或者l = mid。因为r更新为mid-1，如果mid仍然计算下取整，则l和r差1时大者永远取不到，会死循环，因此计算mid时需要加1。 1234567891011int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + 1ll + r &gt;&gt; 1; // 最后一个小于等于key的数 if (a[mid] &lt;= key) if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 浮点数二分 注意while判断条件考虑浮点误差应为while (r - l &gt; eps) 1234567891011double bsearch_3(double l, double r)&#123; const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125; 旋转数组二分 双指针常见题型： 左右指针：三数之和、盛最多水的容器 快慢指针：利用某种单调性确保 i，j两指针保持相同的移动方向 原地移除数据元素、求满足条件的子串 12345678for (int i = 0, j = 0; i &lt; n; i++) &#123; // j在左，i在右 while(j &lt; i &amp;&amp; check(i, j)) &#123; // 具体逻辑 j++; &#125; // 具体逻辑&#125; 最长无重复字符子串注意check的条件是cnt[a[i]]意味着只需要检查新加入的最右端元素的出现次数 123456789101112const int N = 100010;int a[N], cnt[N];int res = 0;for (int i = 0, j = 0; i &lt; n; i++) &#123; cnt[a[i]]++; while(j &lt; i &amp;&amp; cnt[a[i]] &gt; 1) &#123; cnt[a[j]]--; j++; &#125; res = max(res, i - j + 1);&#125; 单调队列12345678int hh = 0, tt = -1;for (int i = 0; i &lt; n; i++) &#123; // 队头滑出 while(hh &lt;= tt &amp;&amp; check_out(hh, i)) hh++; // 队尾保持单调性 while(hh &lt;= tt &amp;&amp; check(tt, i)) tt--; q[++tt] = i; //注意区分队列中存放下标还是元素值&#125; 滑动窗口的最小值12345678910int hh = 0, tt = -1;for (int i = 0; i &lt; n; i++) &#123; // 下标间隔判断不是队列本身，而是队头和当前元素i的下标距离 while(hh &lt;= tt &amp;&amp; i - q[hh] + 1 &gt; k) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; q[ ++ tt] = i; if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl; 滑动窗口12345678910111213int left = 0, right = 0;while (left &lt; right &amp;&amp; right &lt; nums.size()) &#123; // 增大窗口 window.add(nums[right]); right++; while (window needs shrink) &#123; // 缩小窗口 window.remove(nums[left]); left++; &#125;&#125; 最小覆盖子串123456789101112131415161718192021222324252627string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; hash; for (auto &amp;c : t) &#123; hash[c]++; &#125; int cnt = hash.size(); int l = 0, r = 0, valid = 0; string res; int minLen = 1e9; while (r &lt; s.size()) &#123; if (hash[s[r]] == 1) valid++; hash[s[r]]--; // 窗口满足覆盖条件时，尽可能缩小长度 while (valid == cnt &amp;&amp; hash[s[l]] &lt; 0) &#123; hash[s[l]]++; l++; &#125; if (valid == cnt) &#123; if (res.empty() || r - l + 1 &lt; minLen) &#123; res = s.substr(l, r - l + 1); minLen = r - l + 1; &#125; &#125; r++; &#125; return res;&#125; 找到字符串中所有给定子串的字母异位子串12345678910111213141516171819202122vector&lt;int&gt; findAnagrams(string s, string p) &#123; unordered_map&lt;char, int&gt; umap; int cnt = 0; for (auto &amp;c : p) &#123; if (!umap[c]) cnt++; umap[c]++; &#125; int valid = 0; vector&lt;int&gt; res; for (int i = 0, j = 0; i &lt; s.size(); i++) &#123; umap[s[i]]--; if (umap[s[i]] == 0) valid++; // 长度为k的子数组/子串，可直接根据窗口长度判断是否需要缩小窗口 while (i - j + 1 &gt; p.size()) &#123; if (umap[s[j]] == 0) valid--; umap[s[j]]++; j++; &#125; if (valid == cnt) res.push_back(j); &#125; return res;&#125; 和为k的子数组注意这道题如果数组存在负数，则右指针右移，左指针不满足右移的单调性，不能使用滑动窗口。应使用前缀和+哈希： 123456789101112131415int subarraySum(vector&lt;int&gt;&amp; a, int k) &#123; int n = a.size(); vector&lt;int&gt; sum(n+1, 0); for (int i = 1; i &lt;= n; i++) &#123; sum[i] = sum[i-1] + a[i-1]; &#125; unordered_map&lt;int, int&gt; hash; int res = 0; hash[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; res+= hash[sum[i] - k]; hash[sum[i]]++; &#125; return res;&#125; 哈希常见题目：两数之和、和为k的子数组、字母异位词分组、最长连续序列 最长连续序列 12345678910111213141516171819202122int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; int res = 0; // unordered_map&lt;int, int&gt; tr_left, tr_right; // for (auto&amp; x: nums) &#123; // int left = tr_right[x - 1]; // int right = tr_left[x + 1]; // tr_left[x - left] = max(tr_left[x - left], left + 1 + right); // tr_right[x + right] = max(tr_right[x + right], left + 1 + right); // res = max(res, left + 1 + right); // &#125; unordered_set&lt;int&gt; set(nums.begin(), nums.end()); for (auto&amp; x: nums) &#123; if (set.find(x-1) != set.end()) continue; int cur = 1, curVal = x; while (set.find(curVal+1) != set.end()) &#123; cur++; curVal++; &#125; res = max(res, cur); &#125; return res;&#125; 单调栈单调性：元素下标i &lt; j 但元素值 a[i] &gt; a[j]时，a[j]必定有更长的生命周期，a[i]可被删除，因此最终栈内元素始终单调递增 求数组每个元素左边第一个比它小/大的元素12345int hh = 0;for (int i = 0; i &lt; n; i++) &#123; while (hh &gt; 0 &amp;&amp; stk[hh] &gt;= a[i]) hh--; stk[++hh] = a[i]; // 注意区分栈中存放下标还是元素值&#125; 接雨水123456789101112131415int trap(vector&lt;int&gt;&amp; a) &#123; int n = a.size(); stack&lt;int&gt; st; int res = 0; for (int i = 0; i &lt; n; i++) &#123; while (!st.empty() &amp;&amp; a[i] &gt;= a[st.top()]) &#123; int t = st.top(); st.pop(); if (st.empty()) break; res += (min(a[i], a[st.top()]) - a[t]) * (i - st.top() - 1); &#125; st.push(i); &#125; return res;&#125; 柱状图最大矩形面积123456789101112def largestRectangleArea(self, heights) -&gt; int: stack = [] heights = [0] + heights + [0] n = len(heights) res = 0 for i in range(n): # print(stack) while stack and heights[stack[-1]] &gt; heights[i]: cur = stack.pop() res = max(res, (i - stack[-1] - 1) * heights[cur]) stack.append(i) return res 二叉树数据结构的遍历形式主要分为迭代和递归，二叉树由于其非线性，只能采用递归遍历形式： 1234567void traverse(TreeNode* root) &#123; // 前序位置 traverse(root-&gt;left); // 中序位置 traverse(root-&gt;right); // 后序位置&#125; 二叉树的解题思路分为两种：一是递归遍历二叉树，二是分解子问题。回溯通常定义一个返回值为空的函数做递归遍历，分治定义的函数返回子树的计算结果。以前序遍历为例： 1234567891011121314151617181920212223242526272829// 回溯思想vector&lt;int&gt; preorder(TreeNode* root) &#123; vector&lt;int&gt; res; traverse(root, res); return res;&#125;void traverse(TreeNode* root, vector&lt;int&gt;&amp; res) &#123; if (root == NULL) &#123; return; &#125; res.push_back(root-&gt;val); traverse(root-&gt;left); traverse(root-&gt;right);&#125;// 分治思想vector&lt;int&gt; preorder(TreeNode* root) &#123; vector&lt;int&gt; res; if (root == NULL) &#123; return res; &#125; res.push_back(root-&gt;val); vector&lt;int&gt; left = preorder(root-&gt;left); vector&lt;int&gt; right = preorder(root-&gt;right); // 后序位置可以通过函数返回值获取子树传递回来的数据 res.insert(res.end(), left.begin(), left.end()); res.insert(res.end(), right.begin(), right.end()); return res;&#125; 二叉树的层序遍历：本质是BFS 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; levelTraverse(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (root == NULL) return res; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) &#123; int sz = que.size(); vector&lt;int&gt; tmp; for (int i = 0; i &lt; sz; i++) &#123; TreeNode* cur = que.front(); tmp.push_back(cur-&gt;val); que.pop(); if (cur-&gt;left) que.push(cur-&gt;left); if (cur-&gt;right) que.push(cur-&gt;right); &#125; res.push_back(tmp); &#125; return res;&#125; 二叉搜索树：左子树均小于根节点，右子树均大于根节点 二叉搜索树的最近公共祖先 123456789101112131415TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; TreeNode* ancestor = root; while (true) &#123; if (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123; ancestor = ancestor-&gt;left; &#125; else if (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123; ancestor = ancestor-&gt;right; &#125; else &#123; break; &#125; &#125; return ancestor;&#125; 快速排序/快速选择快速排序 $O(nlgn)$ 12345678910111213void qSort(int q[], int l, int r)&#123; if (l &gt;= r) return; // x选择q[l]或下中位数，递归子区间选[l, j], [j + 1, r] int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; qSort(q, l, j), qSort(q, j + 1, r);&#125; 快速选择$O(n)$ 1234567891011121314151617int qSelect(vector&lt;int&gt;&amp; a, int l, int r, int k) &#123; if (l == r) return a[l]; int x = a[l], i = l - 1, j = r + 1; while (i &lt; j) &#123; while(a[++ i] &lt; x); while(a[-- j] &gt; x); if (i &lt; j) &#123; swap(a[i], a[j]); &#125; &#125; int cnt = j - l + 1; if (cnt &gt;= k) return qSelect(a, l, j, k); else return qSelect(a, j + 1, r, k - cnt);&#125; #### 堆/优先队列堆是满足任一父节点大于/小于其子节点的完全二叉树。 插入元素 右下插入 12heap[++size] = x;up(size); 删除堆顶 交换后删除右下元素 123heap[1] = heap[size];size--;down(1); 删除任一元素 1234heap[k] = heap[size];size--;down(k);up(k); $O(1)$时间建堆，数列错位相减可证明 123for (int i = n / 2; i; i--) &#123; down(i);&#125; 通用操作 123456789101112131415void down(int u) &#123; int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) &#123; swap(h[u], h[t]); down(t); &#125;&#125;void up(int u) &#123; while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) &#123; swap(h[u], h[u / 2]); u &gt;&gt;= 1; &#125;&#125; 最大堆 1priority_queue, greater &gt; que; 最小堆 1priority_queue que; 前k大的数快速选择算法 $O(n)$ + 排序$O(klgk)$ 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; qSelect(vector&lt;int&gt;&amp; a, int l, int r, int k) &#123; if (l == r) &#123; vector&lt;int&gt; res(a.begin(), a.begin()+l+1); return res; &#125; int x = a[l], i = l - 1, j = r + 1; while (i &lt; j) &#123; while(a[++ i] &lt; x); while(a[-- j] &gt; x); if (i &lt; j) &#123; swap(a[i], a[j]); &#125; &#125; int cnt = j - l + 1; if (cnt &gt;= k) return qSelect(a, l, j, k); else return qSelect(a, j + 1, r, k - cnt); &#125; vector&lt;int&gt; getLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int n = input.size(); if (!n) return &#123;&#125;; vector&lt;int&gt; res = qSelect(input, 0, n - 1, k); sort(res.begin(), res.end()); return res; &#125;&#125;; 最小堆（注意求前k大的数应该用最小堆）$O(nlgk)$ C++优先队列默认为最大堆，greater为最小堆 1234567891011121314151617181920vector&lt;int&gt; getLastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap; for (int i = 0; i &lt; input.size(); i++) &#123; // heap.push(input[i]); // if (heap.size() &gt; k) heap.pop(); if (heap.size() &lt; k) &#123; heap.push(input[i]); &#125; else if (input[i] &gt; heap.top()) &#123; heap.push(input[i]); heap.pop(); &#125; &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; k; i++) &#123; res.push_back(heap.top()); heap.pop(); &#125; reverse(res.begin(), res.end()); return res; &#125; 数据流的中位数维护一个最大堆来存放较小一半的数和一个最小堆来存放较大一半的树，保证两个堆的数目保持一致或最多差一，如果两堆顶逆序交换即可。 1234567891011121314151617181920priority_queue&lt;int&gt; maxHeap;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;void insert(int num)&#123; maxHeap.push(num); if (minHeap.size() &amp;&amp; minHeap.top() &lt; maxHeap.top()) &#123; auto p = minHeap.top(), q = maxHeap.top(); minHeap.pop(); maxHeap.pop(); minHeap.push(q); maxHeap.push(p); &#125; if (maxHeap.size() - minHeap.size() &gt; 1) &#123; minHeap.push(maxHeap.top()); maxHeap.pop(); &#125;&#125;double getMedian()&#123; if (maxHeap.size() + minHeap.size() &amp; 1) return maxHeap.top(); else return (maxHeap.top() + minHeap.top()) / 2.0; &#125; 归并排序数组归并排序 注意合并时所需额外空间的处理 vector&lt;int&gt; tmp(r - l + 1); 12345678910111213141516void mergeSort(vector&lt;int&gt;&amp; a, int l, int r) &#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; mergeSort(a, l, mid); mergeSort(a, mid + 1, r); vector&lt;int&gt; tmp(r - l + 1); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; &#125; while(i &lt;= mid) tmp[k++] = a[i++]; while(j &lt;= r) tmp[k++] = a[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j];&#125; 合并两个有序链表12345678910111213141516171819202122232425262728293031struct ListNode &#123; int val; ListNode* next;&#125;;ListNode* mergeList(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt;= l2-&gt;val) &#123; cur-&gt;next = l1; l1 = l1-&gt;next; cur = cur-&gt;next; &#125; else &#123; cur-&gt;next = l2; l2 = l2-&gt;next; cur = cur-&gt;next; &#125; &#125; while(l1) &#123; cur-&gt;next = l1; l1 = l1-&gt;next; cur = cur-&gt;next; &#125; while(l2) &#123; cur-&gt;next = l2; l2 = l2-&gt;next; cur = cur-&gt;next; &#125; return dummy-&gt;next;&#125; 链表归并排序快慢指针寻找链表中点 逆序对的数量分治：构成逆序对的两个数同在分治后的左侧区间或右侧区间，或者分别位于左右两个区间需要在归并时计算 归并计算逆序对：对右侧区间的每个数计算左侧区间中大于它的数的个数，最后全部求和 123456789101112131415161718192021222324long long mergeSort(int l, int r) &#123; if (l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; long long res = mergeSort(l, mid) + mergeSort(mid + 1, r); int k = 0, i = l, j = mid + 1; vector&lt;int&gt; tmp(r - l + 1); while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) tmp[k++] = a[i++]; else &#123; res += mid - i + 1; tmp[k++] = a[j++]; &#125; &#125; while(i &lt;= mid) tmp[k++] = a[i++]; while(j &lt;= r) tmp[k++] = a[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j]; return res;&#125; 合并k个有序链表分治或最小堆 #### 回溯法DFS回溯需要恢复状态主要是考虑每次枚举状态转移时当前起始点应保持一致，如果枚举导致其发生变化则需要恢复起始状态 回溯考虑的三要素： 可选择列表、当前路径、枚举顺序(可能需要标记枚举位置) 如果当前选择列表为空： ​ 将当前路径加入答案集合 否则： ​ for choice in 选择列表： ​ 将choice加入当前路径 ​ 将choice移出选择列表 ​ 递归调用 ​ 将choice移除当前路径 ​ 将choice重新加入选择列表 指数枚举 $O(2^n)$123456789101112131415161718192021222324// 递归 状态压缩// state记录当前路径，u从1到n枚举每个位置，每个位置的选择列表即选或不选不受变化影响void dfs(int u, int state) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) &#123; if (state &gt;&gt; i &amp; 1) &#123; cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;; &#125; &#125; cout &lt;&lt; endl; return; &#125; dfs(u + 1, state); dfs(u + 1, state | 1 &lt;&lt; u);&#125;// 递推 状态压缩int n;for (int state = 0; state &lt; 1 &lt;&lt; n; state++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (state &gt;&gt; j &amp; 1) cout &lt;&lt; j + 1 &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 组合枚举 $O(C^k_n)$枚举每个数是否被选中，增加选择k个数的限制条件，为避免组合型枚举重复枚举，人为指定顺序按顺序枚举 123456789101112131415161718192021222324252627282930313233343536373839// 递归int n, m;vector&lt;int&gt; path;void dfs(int u, int num) &#123; if (num + n - u &lt; m) &#123; return; &#125; if (num == m) &#123; for(int i = 0; i &lt; m; i++) &#123; cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; path.push_back(u+1); dfs(u+1, num+1); path.pop_back(); dfs(u+1, num);&#125;// 组合与顺序无关，使用state状态压缩代替path// num记录已选择数目，u按顺序记录可选数的列表void dfs(int u, int num, int state) &#123; if (num + n - u &lt; m) &#123; return; &#125; if (num == m) &#123; for(int i = 0; i &lt; n; i++) &#123; if (state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; dfs(u + 1, num + 1, state | 1 &lt;&lt; u); dfs(u + 1, num, state);&#125;// 非递归栈模拟 排列枚举 $O(n!)$1234567891011121314151617181920int n;vector&lt;int&gt; path;// u从1到n枚举每个位置，visited记录可选列表void dfs(int u, int visited) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!(visited &gt;&gt; i &amp; 1)) &#123; path.push_back(i + 1); dfs(u + 1, visited | 1 &lt;&lt; i); path.pop_back(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; permutation(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); path.resize(nums.size()); dfs(nums, 0, 0, 0); return ans; &#125; void dfs(vector&lt;int&gt;&amp; nums, int u, int start, int state) &#123; if (u == nums.size()) &#123; ans.push_back(path); return; &#125; if (!u || nums[u] != nums[u-1]) start = 0; for (int i = start; i &lt; nums.size(); i++) &#123; if (!(state &gt;&gt; i &amp; 1)) &#123; path[i] = nums[u]; dfs(nums, u+1, i+1, state | 1 &lt;&lt; i); &#125; &#125; &#125;&#125;; 不同的枚举顺序 枚举每一个位置 i , 用state确定位置 i 是否用过，在每个位置上都尝试填数组第u个数 n皇后u标记决策树每层表示棋盘的行数，每行枚举列的每个位置 12345678910111213141516171819202122232425const int N = 10;int n;char maze[N][N];bool col[N], dg[N], udg[N];void dfs(int u) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; maze[i][j]; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[u - i + n]) &#123; col[i] = dg[u + i] = udg[u - i + n] = true; maze[u][i] = &apos;Q&apos;; dfs(u + 1); maze[u][i] = &apos;.&apos;; col[i] = dg[u + i] = udg[u - i + n] = false; &#125; &#125; &#125; 带返回值的DFS/矩阵路线型判断矩阵中是否存在某字符串路径 1234567891011121314151617181920212223bool dfs(vector&lt;vector&lt;char&gt;&gt; &amp;matrix, string &amp;str, int u, int x, int y) &#123; if (matrix[x][y] != str[u]) return false; if (u == str.size() - 1) return true; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; char t = matrix[x][y]; matrix[x][y] = &apos;*&apos;; for (int i = 0; i &lt; 4; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; matrix.size() &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; matrix[a].size()) &#123; if (dfs(matrix, str, u + 1, a, b)) return true; &#125; &#125; matrix[x][y] = t; return false;&#125;bool hasPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string str) &#123; for (int i = 0; i &lt; matrix.size(); i ++ ) for (int j = 0; j &lt; matrix[i].size(); j ++ ) if (dfs(matrix, str, 0, i, j)) return true; return false;&#125; 寻找矩阵中价值最大的路径 1234567891011121314151617181920212223242526272829303132int n, m;int dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int dx[4] = &#123;0, 0, 1, -1&#125;; int dy[4] = &#123;1, -1, 0, 0&#125;; int tmp = grid[x][y]; int res = tmp, ans = 0; grid[x][y] = 0; for (int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i], ny = y + dy[i]; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; grid[nx][ny]) &#123; ans = max(ans, dfs(nx, ny, grid)); &#125; &#125; grid[x][y] = tmp; res += ans; return res;&#125;int getMaximumGold(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; n = grid.size(); if (!n) return 0; m = grid[0].size(); int res = 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j]) &#123; res = max(res, dfs(i, j, grid)); &#125; &#125; return res;&#125; 递归/DFS空间复杂度 $O(最大递归深度)$ BFS时间复杂度 $O(状态数*转移方式)$ 空间复杂度 $O(状态数)$ 最短距离模型迷宫起点到终点的最少步数1234567891011121314151617181920212223242526272829303132const int INF = 1e8;typedef pair&lt;int, int&gt; PII;queue&lt;PII&gt; que;char maze[N][M];int d[N][M];int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123;0, 1, 0, -1&#125;;for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; d[i][j] = INF; &#125;&#125;int sx, sy, gx, gy;que.push(PII(sx, sy));d[sx][sy] = 0;while(!que.empty()) &#123; PII p = que.front(); que.pop(); if (p.first == gx &amp;&amp; p.second == gy) break; for (int i = 0; i &lt; 4; i++) &#123; int nx = p.first + dx[i]; int ny = p.second + dy[i]; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; maze[nx][ny] != &apos;#&apos; &amp;&amp; d[nx][ny] == INF) &#123; que.push(PII(nx, ny)); d[nx][ny] = d[p.first][p.second] + 1; &#125; &#125;&#125; Flood Fill/连通域计数DFS和BFS均可实现，可在线性时间找到某个点的连通块，但DFS数据较大可能会爆栈 湖泊计数 123456789101112131415161718192021222324252627282930313233343536373839typedef pair&lt;int, int&gt; PII;const int maxn = 100;int n,m;char field[maxn][maxn];int dx[8]=&#123;0,1,1,1,0,-1,-1,-1&#125;;int dy[8]=&#123;1,1,0,-1,-1,-1,0,1&#125;;void dfs(int sx,int sy)&#123; field[sx][sy]=&apos;.&apos;; for (int i = 0; i &lt; 8; i++) &#123; int nx = sx + dx[i]; int ny = sy + dy[i]; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; field[nx][ny]==&apos;W&apos;) dfs(nx, ny);//深度优先搜索无需在judge后标记节点，因为会递归调用；而bfs只调用一次 &#125;&#125;void bfs(int sx,int sy)&#123; queue&lt;P&gt; que; que.push(make_pair(sx, sy)); field[sx][sy]=&apos;.&apos;; while (!que.empty()) &#123; PII p = que.front(); que.pop(); for (int i = 0; i &lt; 8; i++) &#123; int nx = p.first + dx[i]; int ny = p.second + dy[i]; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; field[nx][ny]==&apos;W&apos;) &#123; que.push(make_pair(nx, ny)); field[nx][ny] = &apos;.&apos;; &#125; &#125; &#125;&#125; 最小步数模型棋盘整体从一个状态变换为另一状态所需的最小步数，状态表示通常使用字符串，距离使用哈希 e.x 八数码 （题目链接） 12345678910111213141516171819202122232425262728293031323334353637int bfs(string start) &#123; string end = &quot;12345678x&quot;; queue&lt;string&gt; que; unordered_map&lt;string, int&gt; d; que.push(start); d[start] = 0; while(que.size()) &#123; auto t = q.front(); q.pop(); int dist = d[t]; if (t == end) return dist; int dx[4] = &#123;-1, 0, 1, 0&#125;; int dy[4] = &#123;0, 1, 0, -1&#125;; int k = t.find(&apos;x&apos;); int x = k / 3, y = k % 3; for (int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &gt;= 0 &amp;&amp; nx &lt; 3 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 3) &#123; swap(t[k], t[nx * 3 + b]); if (!d.count(t)) &#123; d[t] = dist + 1; que.push(t); &#125; swap(t[k], t[nx * 3 + b]); // 注意恢复状态 &#125; &#125; &#125; return -1;&#125; e.x 魔板（题目链接） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697char g[2][4];unordered_map&lt;string, int&gt; dist;unordered_map&lt;string, pair&lt;char, string&gt; &gt; pre;string get() &#123; string res; for (int i = 0; i &lt; 4; i++) res += g[0][i]; for (int i = 3; i &gt;= 0; i--) res += g[1][i]; return res;&#125;void set(string s) &#123; for (int i = 0; i &lt; 4; i++) g[0][i] = s[i]; for (int i = 4, j = 3; i &lt; 8; i++, j--) &#123; g[1][j] = s[i]; &#125;&#125;string move1(string s) &#123; set(s); for (int i = 0; i &lt; 4; i++) swap(g[0][i], g[1][i]); return get();&#125;string move2(string s) &#123; set(s); for (int i = 0; i &lt; 2; i++) &#123; char t = g[i][3]; for (int j = 2; j &gt;= 0; j--) g[i][j+1] = g[i][j]; g[i][0] = t; &#125; return get();&#125;string move3(string s) &#123; set(s); char t = g[0][1]; g[0][1] = g[1][1]; g[1][1] = g[1][2]; g[1][2] = g[0][2]; g[0][2] = t; return get();&#125;int bfs(string start, string end) &#123; if (start == end) return 0; queue&lt;string&gt; que; que.push(start); dist[start] = 0; while(!que.empty()) &#123; auto p = que.front(); que.pop(); string m[3]; m[0] = move1(p); m[1] = move2(p); m[2] = move3(p); for(int i = 0; i &lt; 3; i++) &#123; if (!dist.count(m[i])) &#123; dist[m[i]] = dist[p] + 1; pre[m[i]] = &#123;&apos;A&apos; + i, p&#125;; que.push(m[i]); if (m[i] == end) return dist[m[i]]; &#125; &#125; &#125; return -1;&#125;int main() &#123; string end; for (int i = 0; i &lt; 8; i++) &#123; int a; cin &gt;&gt; a; end += a + &apos;0&apos;; &#125; string start = &quot;12345678&quot;; int cnt = bfs(start, end); cout &lt;&lt; cnt &lt;&lt; endl; if (cnt &gt; 0) &#123; string res; string s = end; while (s != start) &#123; res += pre[s].first; s = pre[s].second; &#125; reverse(res.begin(), res.end()); cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; 图图的表示： 邻接矩阵int G [maxv][maxv]或&lt;vector&lt;vector&lt;int&gt; &gt; G 邻接表vector&lt;int&gt; G[maxv] 邻接表边带权： struct edge { int to; int cost; }vector&lt;edge&gt; G[maxv] 123456789//读入cin &gt;&gt; V &gt;&gt; E;for (int i = 0; i &lt; E; i++) &#123; int s, t; cin &gt;&gt; s &gt;&gt; t; G[s].push_back(G[t]); //无向图 G[t].push_back(G[s]);&#125; 并查集静态连通性问题使用BFS/DFS，动态连通性问题使用并查集 连通本质上是一种等价关系，满足自反性、对称性和传递性 按秩合并：增加树高rank数组，每次从rank小的树向rank大的树连边，避免退化 路径压缩：每次查询到根节点将该节点的parent直接连到根 对n个元素的并查集操作一次时间$O(α(n))$，$α$为阿克曼函数的反函数，比$O(lgn)$快。 1234567891011121314151617181920212223242526void init() &#123; vector&lt;int&gt; par(n); vector&lt;int&gt; rank(n, 0); for (int i = 0; i &lt; n; i++) &#123; par[i] = i; &#125;&#125;int find (int x, vector&lt;int&gt;&amp; par) &#123; return par[x] == x? x : par[x] = find(par[x], par);&#125;void unite(int x, int y, vector&lt;int&gt;&amp; par, vector&lt;int&gt;&amp; rank) &#123; x = find(x, par); y = find(y, par); if (x == y) return; else if (rank[x] &lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; // x为根且高度需加1 if (rank[x] == rank[y]) rank[x]++; &#125; &#125; 边带权并查集根节点绑定集合元素的大小 ​ 对于迷宫包围问题，可以利用虚拟节点营造出连通特性 每个元素绑定点到根节点的距离，适用于多分类的情况 扩展域并查集对于合法性问题利用并查集等价关系 POJ1182 食物链 动态规划 状态表示 f(i, j) 表示集合[i, j]的某一属性，例如集合中的最大值、最小值或数量 状态计算 根据集合的划分计算 时间复杂度：状态数目 * 状态转移方式 空间复杂度：子问题的个数 背包问题N个物品，体积为V的背包，每类物品体积为$v_i$，价值权重为$w_i$，求满足体积限制的背包的最大价值 01背包每类物品只能用一次 状态f(i, j) 表示从前i类物品中选，所选物品体积小于j的所有选法的集合中 价值最大选法的价值 12345678910111213f[0][0-V] = 0for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) &#123; f[i][j] = f[i-1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); &#125;// 滚动数组优化，因为f中i只用到i-1且j只用到左侧j和j-v[i]，因此可用一维数组从大到小滚动优化f[0][0-V] = 0for (int i = 1; i &lt;= n; i++) for (int j = m; j &gt;= v[i]; j--) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; 完全背包每类物品可以使用无限次，与01背包的区别主要在于集合的划分变为$f[i, j] = f[i-1, j-v[i]k] + kw[i]$ 因此完全背包的状态计算可以优化为$f[i, j] = max(f[i-1, j], f[i, j-v[i]] + w[i])$，优化后可以使用滚动数组进一步简化为一维，和01背包只有j的计算顺序不同 多重背包每类物品有$s_i$个，与完全背包状态划分计算相同，只不过k由$s[i]$约束. 多重背包的优化 二进制拆分优化 由 $O(NS)$优化至$O(N\lg S)$ 分组背包每组物品只能选一个，状态f(i, j)的划分根据第i组物品选第k个来拆分计算 1// f[i][j] = max(f[i-1][j], f[i-1][j - v[i][k]] + w[i][k])k 计数DP方案数类初始化通常为f[0] = 1，因为空集也可以看作一种划分方案 整数划分方案数求1到n中任意个数之和为x的方案数 转换为完全背包问题，状态f(i, j)表示为从1-i个数中选择（每个数可选无数次）使得和恰好为j的方案数 状态计算f[i][j] = f[i-1][j] + f[i-1, j-i] + f[i-1][j-2*i] +... f[i][j] = f[i - 1][j] + f[i, j - i] 状态f(i, j)表示所有总和为i恰好表示为j个数之和的方案数，状态计算根据j个数的最小值是否为1划分，对于最小值为1的情况，可以由去掉1的状态f(i - 1, j - 1)转移而来；对于最小值大于1的情况，可以由每个数减去1的状态f(i - j, j)转移而来 f[i][j] = f[i-1, j-1] + f[i - j][j] 线性DP递推顺序是线性序列 数字三角形状态f(i, j) 表示从起点走到(i, j)的所有路径的集合 注意 i 表示水平方向，j表示左下倾斜方向，初始化时需要注意f[i][j+1]右哨兵也会被用到 1// f[i][j] = max(f[i-1][j-1], f[i-1][j]) + a[i][j] 最长上升子序列状态f(i) 表示以i结尾的所有上升子序列的集合 状态划分根据上一个数位置分类 1f[i] = max(f[j] + 1), j = 0, 1, 2,...,i-1 &amp;&amp; a[j] &lt; a[i] // TODO 优化 状态f(i)表示长度为i+1的上升子序列中末尾元素的最小值 由$O(n^2)$优化为$O(n\lg n)$ 最长公共子序列f(i, j) 表示s1[1..i]和s2[1..j]的所有公共子序列 状态划分根据s1[i]和s2[j]是否包含在子序列中分为四类： 1f[i, j] = max(f[i-1][j], f[i][j-1], f[i-1][j-1] + 1, f[i-1][j-1]); 编辑距离注意编辑距离的初始化 12345678910for (int i = 0; i &lt;= p; i++) f[i][0] = i;for (int j = 0; j &lt;= q; j++) f[0][j] = j;for (int i = 1; i &lt;= p; i++) for (int j = 1; j &lt;= q; j++) &#123; f[i][j] = min(f[i-1][j], f[i][j-1]) + 1; if (s1[i-1] == s2[j-1]) f[i][j] = min(f[i][j], f[i-1][j-1]); else f[i][j] = min(f[i][j], f[i-1][j-1] + 1); &#125; 区间DP状态表示某区间，递推通常先循环区间长度，再循环区间左起点 石子合并状态f(i, j)表示将第 i 堆到第 j 堆合并的所有合并方式中代价的最小值，因此每个区间的状态初始化为正无穷 状态划分根据最后一次合并的分界线的位置分类 123456789for (int len = 2; len &lt;= n; len++) for (int i = 1; i + len - 1 &lt;= n; i++) &#123; int l = i, r = i + len - 1; f[l][r] = 2e8; for (int k = l; k &lt; r; k++) &#123; int t = f[l][k] + f[k+1][r] + a[r] - a[l-1]; f[l][r] = min(f[l][r], t); &#125; &#125; 能量项链凸多边形的划分方案状态划分：根据[L, R]边所属的三角形的另一个顶点位置来划分 1234567for (int len = 3; len &lt;= n + 1; len ++ ) for (int l = 1; l + len - 1 &lt;= n * 2; l ++ ) &#123; int r = l + len - 1; for (int k = l + 1; k &lt; r; k ++ ) f[l][r] = max(f[l][r], f[l][k] + f[k][r] + w[l] * w[k] * w[r]); &#125; 数位DP数位DP通常用于解决两个整数a，b之间存在多少满足某个条件的数（且条件与数字每一位有关）的问题。假设给定数x，包含n位，表示为$t_nt_{n-1}…t_1$，那么当我们求解n位数字$t_nt_{n-1}…t_1$的状态所对应的答案时就需重复计算n-1位数字$t_{n-1}t_{n-2}…t_1$的状态所对应的答案，因此具有重复子问题。考虑DP状态为dp(idx, tight, sum) 计数问题给定两个整数 a 和 b，求 a 和 b 之间的所有数字中x的出现次数，x属于0到9 count(int n, int x) 假设一个数为abcdefg，对1 &lt;= pppxqqq &lt;= abcdefg分类讨论： 如果ppp = 000 到 abc-1: 如果x不为0, qqq可以取000到999, cnt = abc * 1000 如果x为0, qqq可以取000到999, 但由于x为0,ppp不能为0只能从001到abc-1, cnt = (abc-1)* 1000 如果ppp = abc : d &lt; x, cnt = 0 d = x, qqq可以取000到efg, cnt = efg + 1 d &gt; x, qqq可以取000到999, cnt = 1000 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int getNum(vector&lt;int&gt; &amp;nums, int l, int r) &#123; int res = 0; for (int i = l; i &gt;= r; i--) &#123; res = res * 10 + nums[i]; &#125; return res;&#125;int power10(int x) &#123; int res = 1; while (x--) &#123; res *= 10; &#125; return res;&#125;int count (int n, int x) &#123; if (!n) return 0; vector&lt;int&gt; nums; do &#123; nums.push_back(n % 10); n /= 10; &#125; while(n); n = nums.size(); int res = 0; for (int i = n - 1 - !x; i &gt;= 0; i--) &#123; if (i &lt; n - 1) &#123; res += getNum(nums, n-1, i+1) * power10(i); if (!x) res -= power10(i); &#125; if (nums[i] &gt; x) res += power10(i); if (nums[i] == x) res += getNum(nums, i-1, 0) + 1; &#125; return res;&#125;int main() &#123; int a, b; while (cin &gt;&gt; a &gt;&gt; b &amp;&amp; (a || b)) &#123; if (a &gt; b) swap(a, b); for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; count(b, i) - count(a-1, i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125; 状态DP状态DP的初始化通常将不合法状态的f值初始化为正无穷或负无穷 不能打劫相邻位置的偷盗最大值状态f[i]表示打劫第i家的最大值 f[i] = max(f[i-1], f[i-2] + a[i]) 状态f[i]拆分为两个状态，f[i][0]表示打劫至第i家且不选当前位置，f[i][1]表示打劫至第i家且选当前位置，状态机的边表示从当前i转移到i+1的路径 1234567891011121314151617181920const int N = 100001;int a[N], f[N][2];int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; f[0][0] = 0; f[0][1] = a[0]; for (int i = 1; i &lt; n; i++) &#123; f[i][0] = max(f[i-1][1], f[i-1][0]); f[i][1] = f[i-1][0] + a[i]; &#125; cout &lt;&lt; max(f[n-1][0], f[n-1][1]) &lt;&lt; endl; &#125;&#125; 股票买卖只能买卖一次 记录最小值和最大差值 无限次买卖 贪心交易所有上涨交易 最多进行k次交易 手中持有股票状态为1，未持有股票状态为0 f[i, j, 0]表示前i天已经进行j次交易且当前无股票 f[i, j, 1]表示前i天正在进行j次交易且当前有股票 含一天冷冻期 f[i, 0]表示前i天且当前有股票 f[i, 1]表示前i天且当前在冷冻期 f[i, 2]表示前i天且当前无股票且不在冷冻期 f[i][0] = max(f[i-1][0], f[i-1][2] - w[i]) f[i][1] = f[i-1][0] + w[i] f[i][2] = max(f[i-1][1], f[i-1][2]) 状态压缩DP状态表示中的某一下标表示的是由状压state表示的集合 集合类 - 最短Hamilton路径状态f(i, j)表示从0走到j，走过的点的集合是i的二进制表示的所有路径的集合的路径长度的最小值 状态计算根据上一点的位置是0, 1,…, n-1划分 f[i][j] = min(f[i - {j}][k] + a[k][j]), k = 0, 1, 2,...,n-1 12345678910111213141516171819202122232425const int N = 20, M = 1 &lt;&lt; N;int a[N][N], f[M][N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; a[i][j]; memset(f, 0x3f, sizeof f); f[1][0] = 0; // f[i][j] 表示走过的点集合为i，走到点j的所有路径 // 根据上一点k的不同取法划分计算 f[i][j] = f[i - &#123;j&#125;][k] + a[k][j] for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; n; j++) // 注意判断状态的合法性 if (i &gt;&gt; j &amp; 1) &#123; for (int k = 0; k &lt; n; k++) if (i &gt;&gt; k &amp; 1) &#123; f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + a[k][j]); &#125; &#125; cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n-1] &lt;&lt; endl;&#125; 棋盘类 - 骨牌的完美覆盖状态f(i, j)表示第i列第j个状态，j状态位等于1表示上一列有横放格子，本列有格子捅出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int N = 12, M = 1 &lt;&lt; 12;long long f[N][M];bool st[M];bool check(int j, int k, int n) &#123; int x = j | k; int cnt = 0; // 下面做法错误，因为没有考虑二进制状态表示中前导0为奇数个的情况 // do &#123; // if (x % 2 == 0) cnt ++; // else &#123; // if (cnt &amp; 1) return false; // cnt = 0; // &#125; // x /= 2; // &#125; while(x); // if (cnt &amp; 1) return false; for (int i = 0; i &lt; n; i++) &#123; if (x &gt;&gt; i &amp; 1) &#123; if (cnt &amp; 1) return false; cnt = 0; &#125; else cnt ++; &#125; if (cnt &amp; 1) return false; return true;&#125;int main() &#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n || m) &#123; memset(f, 0, sizeof f); f[0][0] = 1; for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123; int cnt = 0; st[j] = true; for (int i = 0; i &lt; n; i++) &#123; if (j &gt;&gt; i &amp; 1) &#123; if (cnt &amp; 1) &#123; st[j]=false; break; &#125; cnt = 0; &#125; else cnt ++; &#125; if (cnt &amp; 1) st[j] = false; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123; for (int k = 0; k &lt; (1 &lt;&lt; n); k++) &#123; // j 和 k 同一位不都为1 // j 和 k 不能为连续奇数个0 if (!(j &amp; k) &amp;&amp; st[j | k]) &#123; f[i][j] += f[i-1][k]; &#125; &#125; &#125; &#125; cout &lt;&lt; f[m][0] &lt;&lt; endl; &#125;&#125; 树形DP没有上司的舞会]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer题目总结]]></title>
    <url>%2F2019%2F11%2F21%2Fjianzhi%2F</url>
    <content type="text"><![CDATA[旋转数组的最小数字二分，注意处理单调递增和存在多个相同元素的情况，例如1，0，1，1，1 int findMin(vector&lt;int&gt;&amp; a) { int n = a.size(); if (n == 0) return -1; while (n &gt; 1 &amp;&amp; a[0] == a[n-1]) n--; if (a[0] &lt; a[n-1]) return a[0]; int x = a[0]; int l = 0, r = n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (a[mid] &lt; x) r = mid; else l = mid + 1; } return a[l]; } 二维数组查找 1234567891011121314151617class Solution &#123;public: bool searchArray(vector&lt;vector&lt;int&gt;&gt; array, int target) &#123; int n = array.size(); if (!n) return false; int m = array[0].size(); if (!m) return false; for (int i = 0, j = m - 1; i &lt; n &amp;&amp; j &gt;= 0;) &#123; int t = array[i][j]; if (t == target) return true; if (t &gt; target) j--; else i++; &#125; return false; &#125;&#125;; 找到数组中的重复数字置换法 123456789101112131415int duplicateInArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; if (nums[i] &lt; 0 || nums[i] &gt; n - 1) return -1; &#125; for (int i = 0; i &lt; n; i++) &#123; while(nums[i] != i) &#123; if (nums[i] == nums[nums[i]]) return nums[i]; swap(nums[i], nums[nums[i]]); &#125; &#125; return -1;&#125; 下标对应元素个数二分 统计根据下标划分的区间内的元素个数，根据有重复元素的区间元素个数大于区间长度的性质二分 1234567891011int duplicateInArray(vector&lt;int&gt;&amp; nums) &#123; int l = 1, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; // 划分的区间：[l, mid], [mid + 1, r] int s = 0; for (auto x : nums) s += x &gt;= l &amp;&amp; x &lt;= mid; if (s &gt; mid - l + 1) r = mid; else l = mid + 1; &#125; return r;&#125; 寻找缺失的数字数组有序，对下标进行二分 // 二分，特殊情况：当所有数都满足nums[i] == i时，表示缺失的是 n int getMissingNumber(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int l = 0, r = nums.size() - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (nums[mid] != mid) r = mid; else l = mid + 1; } if (nums[r] == r) r ++ ; return r; } 数组无序，索引补位，将所有的索引和元素做异或运算，只剩落单元素 异或运算满足结合律和交换律 123456789int getMissingNumber(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); int res = 0; res ^= n; for (int i = 0; i &lt; n; i++) &#123; res ^= i ^ nums[i]; &#125; return res;&#125; 调整数组使奇数排在偶数前不要求保证原始稳定顺序的话可以使用双指针 void reOrderArray(vector&lt;int&gt; &amp;a) { int l = 0, r = a.size() -1; while (l &lt; r) { while (l &lt; r &amp;&amp; a[l] % 2 == 1) l++; while (l &lt; r &amp;&amp; a[r] % 2 == 0) r--; if (l &lt; r) swap(a[l], a[r]); } } 数组中出现次数超过一半的数字hash计数 排序，输出位于len/2位置的元素 多数投票问题，Boyer-Moore Majority Vote Algorithm，时间复杂度为 O(N) 使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt–，当cnt为0时将统计元素置为当前元素并令cnt = 1。 如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找一定能找出 majority。 int moreThanHalfNum_Solution(vector&lt;int&gt;&amp; nums) { int cnt = 0, val = -1; for (auto x : nums) { if (!cnt) { cnt = 1; val = x; } else { if (val == x) cnt++; else cnt--; } } return val; } 最长不含重复字符的子字符串双指针 int longestSubstringWithoutDuplication(string s) { unordered_map&lt;char,int&gt; hash; int res = 0; for (int i = 0, j = 0; j &lt; s.size(); j ++ ) { if ( ++ hash[s[j]] &gt; 1) { while (i &lt; j) { hash[s[i]]--; i ++ ; if (hash[s[j]] == 1) break; } } res = max(res, j - i + 1); } return res; } 用两个栈实现队列12// push(x)，我们直接将x插入主栈中即可。// pop()，此时我们需要弹出最先进入栈的元素，也就是栈底元素。我们可以先将所有元素从主栈中弹出，压入辅助栈中。/ // 则辅助栈的栈顶元素就是我们要弹出的元素，将其弹出即可。然后再将辅助栈中的元素全部弹出，压入主栈中。 顺时针打印矩阵12345678910111213141516171819202122vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; int n = matrix.size(); vector&lt;int&gt; res; if (n == 0) return res; int m = matrix[0].size(); int dx[4] = &#123;0, 1, 0, -1&#125;; int dy[4] = &#123;1, 0, -1, 0&#125;; int x = 0, y = 0, d = 0; vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m, false)); for (int i = 0; i &lt; n * m; i++) &#123; res.push_back(matrix[x][y]); st[x][y] = true; int a = x + dx[d], b = y + dy[d]; if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || st[a][b]) &#123; d = (d + 1) % 4; a = x + dx[d], b = y + dy[d]; &#125; x = a; y = b; &#125; return res;&#125; 矩阵中是否存在字符串路径1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string &amp;str, int x, int y, int u) &#123; if (matrix[x][y] != str[u]) return false; if (u == str.size() - 1) return true; matrix[x][y] = &apos;.&apos;; for (int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; matrix[nx][ny] != &apos;.&apos;) &#123; if (dfs(matrix, str, nx, ny, u+1)) return true; &#125; &#125; matrix[x][y] = str[u]; return false; &#125; bool hasPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string &amp;str) &#123; n = matrix.size(); if (n == 0) return false; m = matrix[0].size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (dfs(matrix, str, i, j, 0)) &#123; return true; &#125; &#125; &#125; return false; &#125; private: int n, m; int dx[4] = &#123;0, 0, 1, -1&#125;; int dy[4] = &#123;1, -1, 0, 0&#125;;&#125;; 2sumvector&lt;int&gt; findNumbersWithSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; hash; for (auto x : nums) { if (hash.count(target-x)) { return vector&lt;int&gt;{target - x, x}; } hash[x] = 1; } return vector&lt;int&gt;(); } 斐波那契数列滚动数组递推 矩阵快速幂 丑数int getUglyNumber(int n) { vector&lt;int&gt; dp(n); dp[0] = 1; int i2 = 0, i3 = 0, i5 = 0; for(int i = 1; i &lt; n; i++) { int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5; dp[i] = min(next2, min(next3, next5)); if (next2 == dp[i]) i2 ++ ; if (next3 == dp[i]) i3 ++ ; if (next5 == dp[i]) i5 ++ ; } return dp[n-1]; } 剪绳子给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。 每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？ 贪心+数学推导 int maxProductAfterCutting(int length) { if (length == 2) return 1; int res = 1; while (length % 3 == 1) { res *= 4; length -= 4; } while (length % 3 == 2) { res *= 2; length -= 2; } while (length) { res *= 3; length -= 3; } return res; } dp 连续子数组的最大和int maxSubArray(vector&lt;int&gt;&amp; nums) { int s = 0, res = -2e9; for (auto x : nums) { if (s &lt; 0) s = x; else s += x; res = max(res, s); } return res; } 数字序列中某一位的数字int digitAtIndex(int n) { long long i = 1, num = 9, base = 1; while (n &gt; i * num) { n -= i * num; i ++; num *= 10; base *= 10; } int number = base + (n + i - 1) / i - 1; int r = n % i ? n % i : i; for (int j = 0; j &lt; i - r; j ++ ) number /= 10; return number % 10; } #####正则表示式匹配 状态表示：f[i][j]表示p从j开始到结尾，是否能匹配s从i开始到结尾状态转移： 如果p[j+1]不是*通配符： p[j]是正常字符，f[i][j] = s[i] == p[j] &amp;&amp; f[i+1][j+1] p[j]是.，f[i][j] = f[i+1][j+1]如果p[j+1]是星号通配符，f[i][j] = f[i][j+2] || ((s[i] == p[j] || p[j] == &#39;.&#39; ) &amp;&amp; f[i+1][j]) 1234567891011121314151617181920212223242526class Solution &#123;public: int n, m; string s, p; vector&lt;vector&lt;int&gt;&gt; f; bool isMatch(string _s, string _p) &#123; s = _s, p = _p; n = s.size(), m = p.size(); f = vector&lt;vector&lt;int&gt;&gt; (n+1, vector&lt;int&gt; (m+1, -1)); return dp(0, 0); &#125; bool dp (int i, int j) &#123; if (f[i][j] != -1) return f[i][j]; if (j == m) &#123; return f[i][j] = i == n; &#125; bool firstMatch = i &lt; n &amp;&amp; (s[i] == p[j] || p[j] == &apos;.&apos;); if (j + 1 &lt; m &amp;&amp; p[j+1] == &apos;*&apos;) &#123; f[i][j] = dp(i, j+2) || (firstMatch &amp;&amp; dp(i+1, j)); &#125; else &#123; f[i][j] = firstMatch &amp;&amp; dp(i+1, j+1); &#125; return f[i][j]; &#125;&#125;; 不用加减乘除实现加法扑克顺子bool isContinuous( vector&lt;int&gt; nums) { sort(nums.begin(), nums.end()); for (int i = 1; i &lt; nums.size(); i ++ ) if (nums[i] &amp;&amp; nums[i] == nums[i - 1]) return false; for (auto x : nums) if (x) { return nums.back() - x &lt;= 4; } }]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode笔记]]></title>
    <url>%2F2019%2F11%2F15%2Fleetcode-notes%2F</url>
    <content type="text"><![CDATA[LC23 合并k个有序链表 分治法 暴力k个指向k个链表头的指针找最小值O(KN) -&gt; 维护k个元素的最小堆 O(nlgk)最小堆自定义比较函数123456struct Cmp &#123; bool operator() (ListNode* a, ListNode* b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;&#125;注意判读p-&gt;next不为空再加入优先队列 LC 41 缺失的第一个正整数下标置换让n出现在nums[n-1]的位置上，0和负数忽略，注意while循环的判断一定要思考循环是否能有效终止，第二种情况如果交换的两个数相同，则while循环会变为死循环 123456while (nums[i] &gt; 0 &amp;&amp; mums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - 1]) &#123; swap(nums[i], nums[nums[i] - 1]);&#125;// or while (nums[i] &gt;= 0 &amp;&amp; nums[i] &lt; n &amp;&amp; nums[i] != i &amp;&amp; nums[i] != nums[nums[i]]) swap(nums[i], nums[nums[i]]); 或者如果不想考虑下标和正整数元素的差1，可以先将所有元素值减1，负数不处理，但此时要注意INT_MIN不能减。 L2 链表两数相加 记得处理最后进位&gt;0 L7 整数反转 L9 回文数 注意INT溢出情况的处理 字符串的最大公因子 长度满足最大公约数，暴力检查a和b串或者判断a+b == b+a 多数元素 分治 随机化 最长上升子序列优化 最长上升子序列的个数 最长上升连续子序列 最长连续序列 排序 暴力枚举+哈希 并查集 划分和相等的k个子集 分发糖果 矩阵中的增长路径 动态规划和拓扑排序的关系 不同的子序列]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode二叉树]]></title>
    <url>%2F2019%2F10%2F01%2Fbinary-tree%2F</url>
    <content type="text"><![CDATA[Leetcode二叉树常见题目： 重建二叉树递归版本 利用哈希数组记录中序遍历中每个值对应的位置 123456789101112131415161718unordered_map&lt;int,int&gt; pos;TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int n = preorder.size(); for (int i = 0; i &lt; n; i ++ ) pos[inorder[i]] = i; return dfs(preorder, inorder, 0, n - 1, 0, n - 1);&#125;TreeNode* dfs(vector&lt;int&gt;&amp;pre, vector&lt;int&gt;&amp;in, int pl, int pr, int il, int ir)&#123; if (pl &gt; pr) return NULL; int k = pos[pre[pl]] - il; TreeNode* root = new TreeNode(pre[pl]); root-&gt;left = dfs(pre, in, pl + 1, pl + k, il, il + k - 1); root-&gt;right = dfs(pre, in, pl + k + 1, pr, il + k + 1, ir); return root;&#125; 非递归版本 判定二叉搜索树后序序列的合法性注意dfs中[l,r]只包含一个元素的边界判断和子区间递归要剔除根节点 123456789101112131415vector&lt;int&gt; seq;bool verifySequenceOfBST(vector&lt;int&gt; sequence) &#123; seq = sequence; if (seq.size() == 0) return true; return dfs(0, seq.size() - 1);&#125;bool dfs(int l, int r) &#123; if (l &gt;= r) return true; int x = seq[r]; int k = l; while (k &lt; r &amp;&amp; seq[k] &lt; x) k++; for (int i = k; i &lt; r; i++) if (seq[i] &lt; x) return false; return dfs(l, k-1) &amp;&amp; dfs(k, r-1);&#125;&#125;; 二叉搜索树的第k个结点中序遍历的第k个节点，即第k小的结点 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ TreeNode *ans; TreeNode* kthNode(TreeNode* root, int k) { dfs(root, k); return ans; } void dfs(TreeNode *root, int &amp;k) { if (!k || !root) return; dfs(root-&gt;left, k); --k; if (!k) ans = root; else dfs(root-&gt;right, k); } 和为某一定值的二叉树路径DFS 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path;vector&lt;vector&lt;int&gt;&gt; findPath(TreeNode* root, int sum) &#123; dfs(root, sum); return ans;&#125;void dfs(TreeNode* root, int sum) &#123; if (!root) return; path.push_back(root-&gt;val); sum -= root-&gt;val; if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum) ans.push_back(path); dfs(root-&gt;left, sum); dfs(root-&gt;right, sum); path.pop_back(); // sum值传递可以不恢复&#125; 判断对称二叉树 单队列迭代，相邻两个队列成员应该一致 用栈模拟递归，对根节点的左子树中序遍历；对根节点的右子树反中序遍历则两个子树互为镜像，当且仅当同时遍历两课子树时，对应节点的值相等 1234567891011121314151617181920bool isSymmetric(TreeNode* root) &#123; if (!root) return true; stack&lt;TreeNode*&gt; left, right; TreeNode *lc = root-&gt;left; TreeNode *rc = root-&gt;right; while(lc || rc || left.size()) &#123; while (lc &amp;&amp; rc) &#123; left.push(lc), right.push(rc); lc = lc-&gt;left, rc = rc-&gt;right; &#125; if (lc || rc) return false; lc = left.top(), rc = right.top(); left.pop(), right.pop(); if (lc-&gt;val != rc-&gt;val) return false; lc = lc-&gt;right, rc = rc-&gt;left; &#125; return true;&#125; 递归，除根节点外，任意两个子树互为镜像当且仅当： 两个子树的根节点值相等；第一棵子树的左子树和第二棵子树的右子树互为镜像，且第一棵子树的右子树和第二棵子树的左子树互为镜像 bool isSymmetric(TreeNode* root) { if (!root) return true; return dfs(root-&gt;left, root-&gt;right); } bool dfs(TreeNode* l, TreeNode* r) { if (!l || !r) return !l &amp;&amp; !r; return l-&gt;val == r-&gt;val &amp;&amp; dfs(l-&gt;right, r-&gt;left) &amp;&amp; dfs(l-&gt;left, r-&gt;right); } 二叉树的深度int treeDepth(TreeNode* root) { if (!root) return 0; return max(treeDepth(root-&gt;left), treeDepth(root-&gt;right)) + 1; } 平衡二叉树判定bool ans = true; bool isBalanced(TreeNode* root) { dfs(root); return ans; } int dfs(TreeNode *root) { if (!root) return 0; int left = dfs(root-&gt;left), right = dfs(root-&gt;right); if (abs(left - right) &gt; 1) ans = false; return max(left, right) + 1; } 二叉树的下一个结点1234567891011TreeNode* inorderSuccessor(TreeNode* p) &#123; if(!p) return NULL; if (p-&gt;right) &#123; p = p-&gt;right; while(p-&gt;left) p = p-&gt;left; return p; &#125; while(p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p = p-&gt;father; return p-&gt;father;&#125; 生成镜像二叉树所有节点左右孩子互换 void mirror(TreeNode* root) { if (!root) return; swap(root-&gt;left, root-&gt;right); mirror(root-&gt;left); mirror(root-&gt;right); } 同构二叉树两个队列边遍历边比较 树的子结构暴力匹配 找到相同的根节点 同时遍历两颗树 代码分为两个部分： 遍历树A中的所有非空节点R；判断树A中以R为根节点的子树是不是包含和树B一样的结构，且我们从根节点开始匹配；对于第一部分，我们直接递归遍历树A即可，遇到非空节点后，就进行第二部分的判断。 对于第二部分，我们同时从根节点开始遍历两棵子树： 如果树B中的节点为空，则表示当前分支是匹配的，返回true；如果树A中的节点为空，但树B中的节点不为空，则说明不匹配，返回false；如果两个节点都不为空，但数值不同，则说明不匹配，返回false；否则说明当前这个点是匹配的，然后递归判断左子树和右子树是否分别匹配即可； bool hasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { if (!pRoot1 || !pRoot2) return false; if (isSame(pRoot1, pRoot2)) return true; return hasSubtree(pRoot1-&gt;left, pRoot2) || hasSubtree(pRoot1-&gt;right, pRoot2); } bool isSame(TreeNode* pRoot1, TreeNode* pRoot2) { if (!pRoot2) return true; if (!pRoot1 || pRoot1-&gt;val != pRoot2-&gt;val) return false; return isSame(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; isSame(pRoot1-&gt;right, pRoot2-&gt;right); } ##### 二叉树的花样遍历加层数 或更改结构体加上int layer; 按之字形顺序打印二叉树将根节点插入队列中；创建一个新队列，用来按顺序保存下一层的所有子节点；对于当前队列中的所有节点，按顺序依次将儿子插入新队列；按从左到右、从右到左的顺序交替保存队列中节点的值；重复步骤2-4，直到队列为空为止。 vector&lt;int&gt; get_val(vector&lt;TreeNode*&gt; level) { vector&lt;int&gt; res; for (auto &amp;u : level) res.push_back(u-&gt;val); return res; } vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt;res; if (!root) return res; vector&lt;TreeNode*&gt;level; level.push_back(root); res.push_back(get_val(level)); bool zigzag = true; while (true) { vector&lt;TreeNode*&gt; newLevel; for (auto &amp;u : level) { if (u-&gt;left) newLevel.push_back(u-&gt;left); if (u-&gt;right) newLevel.push_back(u-&gt;right); } if (newLevel.size()) { vector&lt;int&gt;temp = get_val(newLevel); if (zigzag) reverse(temp.begin(), temp.end()); res.push_back(temp); level = newLevel; } else break; zigzag = !zigzag; } return res; } 分行打印二叉树 滚动数组 12345678910111213141516171819202122232425262728293031vector&lt;int&gt; get_val(vector&lt;TreeNode*&gt; level)&#123; vector&lt;int&gt; res; for (auto &amp;u : level) res.push_back(u-&gt;val); return res;&#125;vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt;res; if (!root) return res; vector&lt;TreeNode*&gt;level; level.push_back(root); res.push_back(get_val(level)); while (true) &#123; vector&lt;TreeNode*&gt; newLevel; for (auto &amp;u : level) &#123; if (u-&gt;left) newLevel.push_back(u-&gt;left); if (u-&gt;right) newLevel.push_back(u-&gt;right); &#125; if (newLevel.size()) &#123; res.push_back(get_val(newLevel)); level = newLevel; &#125; else break; &#125; return res;&#125; 在每行末尾添加null标记 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (!root) return res; queue&lt;TreeNode*&gt; que; que.push(root); que.push(nullptr); vector&lt;int&gt; level; while(que.size()) &#123; auto p = que.front(); que.pop(); if (!p) &#123; if (level.empty()) break; res.push_back(level); level.clear(); que.push(nullptr); &#125; else &#123; level.push_back(p-&gt;val); if (p-&gt;left) que.push(p-&gt;left); if (p-&gt;right) que.push(p-&gt;right); &#125; &#125; return res;&#125; 序列化二叉树 二叉搜索树与双向链表 每次递归返回一个pair&lt;TreeNode*, TreeNode*&gt;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[推荐系统排序算法总结]]></title>
    <url>%2F2019%2F06%2F30%2Franking-recsys%2F</url>
    <content type="text"><![CDATA[多任务Hard参数共享 所有任务共享底层参数，shared-bottom 优点：减少过拟合风险 缺点：效果可能受到任务差异和数据分布带来的影响 Soft参数共享 不同任务的参数间增加约束控制任务的相似性，例如增加L2正则，trace norm 优点：在任务差异会影响公共参数的情况下对最终效果有提升 缺点：模型增加了参数量所以需要更大的数据量来训练模型，而且模型更复杂并不利于在真实生产环境中实际部署使用 MOE(Mixture-of-Experts) 所有任务共享底层若干专家子网络，不同专家网络学习不同角度知识，上层利用门控结构进行加权融合。n个expert network，g是组合experts结果的gating network。g产生n个experts上的概率分布，最终的输出是所有experts的带权加和。 MoE可作为一个基本组成单元，堆叠在大网络中 MMOE 不同上层任务使用不同门控进行专家子网络的融合。优点：不同任务的gating networks可以学习到不同的组合experts的模式，可以捕捉到任务的相关性和区别。 PLE 分层萃取共享，渐进式分离]]></content>
      <categories>
        <category>RecSys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode链表题目总结]]></title>
    <url>%2F2019%2F03%2F25%2Flinked-list%2F</url>
    <content type="text"><![CDATA[Leetcode链表题常用方法总结： dummy node 常用于链表的head可能被修改或删除的情况，可简化单链表没有前向指针所带来的问题，通常使用current = dummy进行遍历，最终返回 dummy-&gt;next 链表中尽量避免new新的节点，而是在原链表上直接操作地址 在插入和删除操作中使用临时变量来存储next指针 反转链表通常需要使用pre指针记录前驱节点 通过两个指针几何变换来解决链表长度、环检测等问题 对于一些依赖后面节点才能完成的操作，通常使用递归来解决 常见题目： 从尾到头打印链表反向迭代器rbegin(), rend()，栈，递归 12345678vector&lt;int&gt; printListReversingly(ListNode* head) &#123; vector&lt;int&gt; res; while (head) &#123; res.push_back(head-&gt;val); head = head-&gt;next; &#125; return vector&lt;int&gt;(res.rbegin(), res.rend());&#125; O(1)时间删除节点替换下一节点的值，直接删除下一个节点 尾节点只能从头遍历 1234void deleteNode(ListNode* node) &#123; node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next;&#125; 删除重复节点123456789101112131415ListNode* deleteDuplication(ListNode* head) &#123; auto dummy = new ListNode(-1); dummy-&gt;next = head; auto p = dummy; while (p-&gt;next) &#123; auto q = p-&gt;next; while (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next; if (p-&gt;next-&gt;next == q) p = p-&gt;next; else p-&gt;next = q; &#125; return dummy-&gt;next;&#125; 倒数第k个节点12345678ListNode* findKthToTail(ListNode* head, int k) &#123; int n = 0; for (auto p = head; p; p = p-&gt;next) n ++ ; if (n &lt; k) return nullptr; auto p = head; for (int i = 0; i &lt; n - k; i ++ ) p = p-&gt;next; return p;&#125; 反转链表1234567891011ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; ListNode* cur = head; while (cur) &#123; ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; &#125; return pre;&#125; 合并两个有序单链表1234567891011121314151617ListNode* merge(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt;= l2 -&gt; val) &#123; cur-&gt;next = l1; cur = cur-&gt;next; l1 = l1-&gt;next; &#125; else &#123; cur-&gt;next = l2; cur = cur-&gt;next; l2 = l2-&gt;next; &#125; &#125; cur-&gt;next = (l1 == NULL ? l2 : l1); return dummy-&gt;next;&#125; 链表归并排序两个链表的第一个公共节点假设公共部分长度为c，两个链表同时走a+b+c步，a + c + b = b + c + a，a走到头就转向b， b走到头转向a，则在公共部分相遇 12345678910ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *p = headA, *q = headB; while (p != q) &#123; if (p) p = p-&gt;next; else p = headB; if (q) q = q-&gt;next; else q = headA; &#125; return p;&#125; 链表环的入口两指针一快一满，快指针以两倍速度行走，必定相遇在环内 下图x+y必定为环的长度的整数倍，因为2(x+y) = x + y + nlen 此时慢指针回到开头 两指针同时重新走x步均回到b点，即环的入口 123456789101112131415161718192021222324252627ListNode *entryNodeOfLoop(ListNode *head) &#123; if (!head || !head-&gt;next) return 0; ListNode *first = head, *second = head; while (first &amp;&amp; second) &#123; first = first-&gt;next; second = second-&gt;next; if (second) second = second-&gt;next; else return NULL; //没有环 if (first == second) &#123; first = head; while (first != second) &#123; first = first-&gt;next; second = second-&gt;next; &#125; return first; &#125; &#125; return 0;&#125; 复杂链表的复制带random指针的listNode节点的复制 使用哈希表保存random指针的原节点和复制节点对应关系 在原链表上穿叉复制节点]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
</search>
