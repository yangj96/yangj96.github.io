<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法模版-初级篇]]></title>
    <url>%2F2020%2F12%2F31%2Falgo-template1%2F</url>
    <content type="text"><![CDATA[目录 二分 递归/DFS BFS 并查集 归并排序 快速排序&amp;快速选择 堆 单调栈 单调队列 位运算 初级图论 高精度 初级数论 二分二分本质不是单调性，只需要区间针对某个性质能够分成两段，一段满足一段不满足即可。 找到能够划分区间左右两半的性质，如果if (check(mid)) 条件成立，判断答案在左区间还是右区间，如果答案在左区间并且mid也可能是答案，按模板1来划分；如果答案在右区间并且mid也可能是答案，按模板2来划分。 模板1mid使用下中位数，模板2使用下中位数+1，终结条件为$low==high$，注意区间左右均为闭区间 版本1最大值最小问题，第一个&gt;=target的元素区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用，其更新操作是r = mid或者l = mid + 1。计算mid时不需要加1。 123456789101112int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; // 两个int相加减会溢出 中间加个长整型常量 int mid = l + 0ll + r &gt;&gt; 1; // 第一个大于等于key的数 if (a[mid] &gt;= key) if (check(mid)) r = mid; else l = mid + 1; &#125; return l;&#125; 版本2最小值最大问题，最后一个&lt;= target的元素区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用，其更新操作是r = mid - 1或者l = mid。因为r更新为mid-1，如果mid仍然计算下取整，则l和r差1时大者永远取不到，会死循环，因此计算mid时需要加1。 1234567891011int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + 1ll + r &gt;&gt; 1; // 最后一个小于等于key的数 if (a[mid] &lt;= key) if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 浮点数二分 注意while判断条件考虑浮点误差应为while (r - l &gt; eps) 1234567891011double bsearch_3(double l, double r)&#123; const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125; 递归/DFS空间复杂度 $O(最大递归深度)$ 指数枚举 $O(2^n)$1234567891011121314151617181920212223// 递归 状态压缩void dfs(int u, int state) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) &#123; if (state &gt;&gt; i &amp; 1) &#123; cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;; &#125; &#125; cout &lt;&lt; endl; return; &#125; dfs(u + 1, state); dfs(u + 1, state | 1 &lt;&lt; u);&#125;// 递推 状态压缩int n;for (int state = 0; state &lt; 1 &lt;&lt; n; state++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (state &gt;&gt; j &amp; 1) cout &lt;&lt; j + 1 &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 组合枚举 $O(C^k_n)$1234567891011121314151617181920212223242526272829303132333435363738// 递归int n, m;vector&lt;int&gt; path;void dfs(int u, int num) &#123; if (num + n - u &lt; m) &#123; return; &#125; if (num == m) &#123; for(int i = 0; i &lt; m; i++) &#123; cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; path.push_back(u+1); dfs(u+1, num+1); path.pop_back(); dfs(u+1, num);&#125;// 组合与顺序无关，使用state状态压缩代替pathvoid dfs(int u, int num, int state) &#123; if (num + n - u &lt; m) &#123; return; &#125; if (num == m) &#123; for(int i = 0; i &lt; n; i++) &#123; if (state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; dfs(u + 1, num + 1, state | 1 &lt;&lt; u); dfs(u + 1, num, state);&#125;// 非递归栈模拟 排列枚举 $O(n!)$12345678910111213141516171819int n;vector&lt;int&gt; path;void dfs(int u, int visited) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!(visited &gt;&gt; i &amp; 1)) &#123; path.push_back(i + 1); dfs(u + 1, visited | 1 &lt;&lt; i); path.pop_back(); &#125; &#125;&#125; BFS时间复杂度 $O(状态数*转移方式)$ 空间复杂度 $O(状态数)$ 迷宫起点到终点的最少步数1234567891011121314151617181920212223242526272829303132const int INF = 1e8;typedef pair&lt;int, int&gt; PII;queue&lt;PII&gt; que;char maze[N][M];int d[N][M];int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123;0, 1, 0, -1&#125;;for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; d[i][j] = INF; &#125;&#125;int sx, sy, gx, gy;que.push(PII(sx, sy));d[sx][sy] = 0;while(!que.empty()) &#123; PII p = que.top(); que.pop(); if (p.first == gx &amp;&amp; p.second == gy) break; for (int i = 0; i &lt; 4; i++) &#123; int nx = p.first + dx[i]; int ny = p.second + dy[i]; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; maze[nx][ny] != &apos;#&apos;) &#123; que.push(PII(nx, ny)); d[nx][ny] = d[p.first][p.second] + 1; &#125; &#125;&#125; 并查集增加树高rank数组，每次从rank小的树向rank大的树连边，避免退化 路径压缩：每次查询到根节点将该节点的parent直接连到根 对n个元素的并查集操作一次时间$O(α(n))$，$α$为阿克曼函数的反函数，比$O(lgn)$快。 1234567891011121314151617181920212223242526void init() &#123; vector&lt;int&gt; par(n); vector&lt;int&gt; rank(n, 0); for (int i = 0; i &lt; n; i++) &#123; par[i] = i; &#125;&#125;int find (int x, vector&lt;int&gt;&amp; par) &#123; return par[x] == x? x : par[x] = find(par[x], par);&#125;void unite(int x, int y, vector&lt;int&gt;&amp; par, vector&lt;int&gt;&amp; rank) &#123; x = find(x, par); y = find(y, par); if (x == y) return; else if (rank[x] &lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; // x为根且高度需加1 if (rank[x] == rank[y]) rank[x]++; &#125; &#125; 边带权并查集扩展域并查集POJ1182 食物链 归并排序数组归并排序 注意合并时所需额外空间的处理 vector&lt;int&gt; tmp(r - l + 1); 12345678910111213141516void mergeSort(vector&lt;int&gt;&amp; a, int l, int r) &#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; mergeSort(a, l, mid); mergeSort(a, mid + 1, r); vector&lt;int&gt; tmp(r - l + 1); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; &#125; while(i &lt;= mid) tmp[k++] = a[i++]; while(j &lt;= r) tmp[k++] = a[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j];&#125; 合并两个有序链表12345678910111213141516171819202122232425262728293031struct ListNode &#123; int val; ListNode* next;&#125;;ListNode* mergeList(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt;= l2-&gt;val) &#123; cur-&gt;next = l1; l1 = l1-&gt;next; cur = cur-&gt;next; &#125; else &#123; cur-&gt;next = l2; l2 = l2-&gt;next; cur = cur-&gt;next; &#125; &#125; while(l1) &#123; cur-&gt;next = l1; l1 = l1-&gt;next; cur = cur-&gt;next; &#125; while(l2) &#123; cur-&gt;next = l2; l2 = l2-&gt;next; cur = cur-&gt;next; &#125; return dummy-&gt;next;&#125; 合并k个有序链表​ 分治或最小堆 链表归并排序逆序对的数量分治：构成逆序对的两个数同在分治后的左侧区间或右侧区间，或者分别位于左右两个区间需要在归并时计算 归并计算逆序对：对右侧区间的每个数计算左侧区间中大于它的数的个数，最后全部求和 1234567891011121314151617181920212223long long mergeSort(int l, int r) &#123; if (l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; long long res = mergeSort(l, mid) + mergeSort(mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) tmp[k++] = a[i++]; else &#123; res += mid - i + 1; tmp[k++] = a[j++]; &#125; &#125; while(i &lt;= mid) tmp[k++] = a[i++]; while(j &lt;= r) tmp[k++] = a[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j]; return res;&#125; 快速排序&amp;快速选择快速排序 $O(nlgn)$ 12345678910111213void qSort(int q[], int l, int r)&#123; if (l &gt;= r) return; // x选择q[l]或下中位数，递归子区间选[l, j], [j + 1, r] int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; qSort(q, l, j), qSort(q, j + 1, r);&#125; 快速选择$O(n)$ 1234567891011121314151617int qSelect(vector&lt;int&gt;&amp; a, int l, int r, int k) &#123; if (l == r) return a[l]; int x = a[l], i = l - 1, j = r + 1; while (i &lt; j) &#123; while(a[++ i] &lt; x); while(a[-- j] &gt; x); if (i &lt; j) &#123; swap(a[i], a[j]); &#125; &#125; int cnt = j - l + 1; if (cnt &gt;= k) return qSelect(a, l, j, k); else return qSelect(a, j + 1, r, k - cnt);&#125; 堆插入元素 右下插入 12heap[++size] = x;up(size); 删除堆顶 交换后删除右下元素 123heap[1] = heap[size];size--;down(1); 删除任一元素 1234heap[k] = heap[size];size--;down(k);up(k); $O(1)$时间建堆，数列错位相减可证明 123for (int i = n / 2; i; i--) &#123; down(i);&#125; 通用操作 123456789101112131415void down(int u) &#123; int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) &#123; swap(h[u], h[t]); down(t); &#125;&#125;void up(int u) &#123; while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) &#123; swap(h[u], h[u / 2]); u &gt;&gt;= 1; &#125;&#125; 最大堆 1priority_queue, greater &gt; que; 最小堆 1priority_queue que; 前k大的数快速选择算法 $O(n)$ + 排序$O(klgk)$ 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; qSelect(vector&lt;int&gt;&amp; a, int l, int r, int k) &#123; if (l == r) &#123; vector&lt;int&gt; res(a.begin(), a.begin()+l+1); return res; &#125; int x = a[l], i = l - 1, j = r + 1; while (i &lt; j) &#123; while(a[++ i] &lt; x); while(a[-- j] &gt; x); if (i &lt; j) &#123; swap(a[i], a[j]); &#125; &#125; int cnt = j - l + 1; if (cnt &gt;= k) return qSelect(a, l, j, k); else return qSelect(a, j + 1, r, k - cnt); &#125; vector&lt;int&gt; getLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int n = input.size(); if (!n) return &#123;&#125;; vector&lt;int&gt; res = qSelect(input, 0, n - 1, k); sort(res.begin(), res.end()); return res; &#125;&#125;; 最小堆（注意求前k大的数应该用最小堆）$O(nlgk)$ 1234567891011121314vector&lt;int&gt; getLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap; for (int i = 0; i &lt; input.size(); i++) &#123; heap.push(input[i]); if (heap.size() &gt; k) heap.pop(); &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; k; i++) &#123; res.push_back(heap.top()); heap.pop(); &#125; reverse(res.begin(), res.end()); return res; &#125; 双指针利用单调性：i，j两指针保持相同的移动方向 常见题型： 单数组 - 满足条件的连续子序列 两数组 - 关键是确定两指针的单向移动方向 12345for (int i = 0, j = 0; i &lt; n; i++) &#123; while(j &lt; i &amp;&amp; check(i, j)) j++; // 具体逻辑&#125; 最长连续不重复子序列注意check的条件是cnt[a[i]]意味着只需要检查新加入的最右端元素的出现次数 1234567891011121314151617const int N = 100010;int a[N], cnt[N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n ;i++) &#123; cin &gt;&gt; a[i]; &#125; int res = 0; for (int i = 0, j = 0; i &lt; n; i++) &#123; cnt[a[i]]++; while(j &lt; i &amp;&amp; cnt[a[i]] &gt; 1) cnt[a[j++]]--; res = max(res, i - j + 1); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; 单调栈单调性：元素下标i &lt; j 但元素值 a[i] &gt; a[j]时，a[j]必定有更长的生命周期，a[i]可被删除，因此最终栈内元素始终单调递增 求数组每个元素左边第一个比它小/大的元素12345int hh = 0;for (int i = 0; i &lt; n; i++) &#123; while (hh &gt; 0 &amp;&amp; stk[hh] &gt;= a[i]) hh--; stk[++hh] = a[i]; // 注意区分栈中存放下标还是元素值&#125; 单调队列12345678int hh = 0, tt = -1;for (int i = 0; i &lt; n; i++) &#123; // 队头滑出 while(hh &lt;= tt &amp;&amp; check_out(hh, i)) hh++; // 队尾保持单调性 while(hh &lt;= tt &amp;&amp; check(tt, i)) tt--; q[++tt] = i; //注意区分队列中存放下标还是元素值&#125; 滑动窗口的最大/小值12345678910int hh = 0, tt = -1;for (int i = 0; i &lt; n; i++) &#123; // 下标间隔判断不是队列本身，而是队头和当前元素i的下标距离 while(hh &lt;= tt &amp;&amp; i - q[hh] + 1 &gt; k) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; q[ ++ tt] = i; if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl; 位运算取最靠右的一位1123int lowbit(int x) &#123; return x &amp; -x;&#125; 二进制中1的个数1234while(x) &#123; x -= lowbit(x); res++;&#125; 获取/设置右起第k位数1234// 获取第k位n &gt;&gt; k &amp; 1// 设置第k位为1n | 1 &lt;&lt; k 初级图论高精度高精度加法数据范围为数字位数而非数字本身，使用string读入，vector逆序存储便于进位 123456789101112131415161718192021222324252627282930vector&lt;int&gt; add(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) &#123; if (a.size() &lt; b.size()) return add(b, a); int t = 0; vector&lt;int&gt; c; for (int i = 0; i &lt; a.size(); i++) &#123; t += a[i]; if (i &lt; b.size()) t += b[i]; c.push_back(t % 10); t /= 10; &#125; if (t) c.push_back(t); return c;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; vector&lt;int&gt; B; for (int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &apos;0&apos;); for (int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - &apos;0&apos;); vector&lt;int&gt; C = add(A, B); reverse(C.begin(), C.end()); for (int i = 0; i &lt; C.size(); i++) &#123; cout &lt;&lt; C[i]; &#125; cout &lt;&lt; endl;&#125; 高精度减法负号的判定 cmp函数：依次判断长度和各个位置的数 减法进位的处理 123c.push_back((t + 10) % 10);if (t &lt; 0) t = 1;else t = 0; 先导0的去除，注意最后结果是0要保留一位0 while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546bool cmp(vector&lt;int&gt; &amp; a, vector&lt;int&gt; &amp; b) &#123; if (a.size() != b.size()) return a.size() &gt; b.size(); for (int i = a.size() - 1; i &gt;= 0; i--) &#123; if (a[i] != b[i]) return a[i] &gt; b[i]; &#125; return true;&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) &#123; int t = 0; vector&lt;int&gt; c; for (int i = 0; i &lt; a.size(); i++) &#123; t = a[i] - t; if (i &lt; b.size()) t -= b[i]; c.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); return c;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; vector&lt;int&gt; B; vector&lt;int&gt; C; for (int i = a.size() - 1; i &gt;= 0; i--) &#123; A.push_back(a[i] - &apos;0&apos;); &#125; for (int i = b.size() - 1; i &gt;= 0; i--) &#123; B.push_back(b[i] - &apos;0&apos;); &#125; if (cmp(A, B)) C = sub(A, B); else &#123; C = sub(B, A); cout &lt;&lt; &quot;-&quot;; &#125; for (int i = C.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; C[i]; &#125; cout &lt;&lt; endl;&#125; 高精度乘法高精度乘整数 12345678910vector&lt;int&gt; mul(vector&lt;int&gt; &amp;a, int b) &#123; vector&lt;int&gt; c; int t = 0; for (int i = 0; i &lt; a.size() || t; i++) &#123; if (i &lt; a.size()) t += a[i] * b; c.push_back(t % 10); t /= 10; &#125; return c;&#125; 高精度乘高精度 123456789101112131415161718vector&lt;int&gt; mul(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) &#123; vector&lt;int&gt; res(alen + blen, 0); // i*j存放i+j for (int i = 0; i &lt; alen; i++) &#123; for (int j = 0; j &lt; blen; j++) &#123; res[i + j] += a[i] * b[j]; &#125; &#125; int t = 0; for (int i = 0; i &lt; (int)res.size(); i++) &#123; t += res[i]; res[i] = t % BASE; t /= BASE; &#125; while (res.size() &gt; 1 &amp;&amp; res.back() == 0) &#123; res.pop_back(); &#125;&#125; 高精度除法]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法模版-中级篇]]></title>
    <url>%2F2020%2F02%2F03%2Falgo-template2%2F</url>
    <content type="text"><![CDATA[目录 双指针/尺取法 离散化 前缀和/差分 区间合并 线段树 中级图论 双指针前缀和/差分一维前缀和s[0] = a[0] = 0 s[i] = s[i-1] + a[i]; 求区间[l, r]元素和s[r] - s[l-1] 二维前缀和一维差分12 二维差分12345678910111213141516const int N = 1005; // 注意数组从1开始且设计N+1，N至少要大于等于2 int b[N][N];void modify(int x1, int y1, int x2, int y2, int c) &#123; b[x1][y1] += c; b[x2+1][y1] -= c; b[x1][y2+1] -= c; b[x2+1][y2+1] += c;&#125;// 复原原矩阵更新值for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法模版-增补]]></title>
    <url>%2F2020%2F02%2F01%2Falgo-add%2F</url>
    <content type="text"><![CDATA[初级篇归并排序逆序对的数量 分治：构成逆序对的两个数同在分治后的左侧区间或右侧区间，或者分别位于左右两个区间需要在归并时计算 归并计算逆序对：对右侧区间的每个数计算左侧区间中大于它的数的个数，最后全部求和 BFS时间复杂度 $O(状态数*转移方式)$ 空间复杂度 $O(状态数)$ 迷宫起点到终点的最少步数 DFS空间复杂度 $O(最大递归深度)$ 简单图论简单数学问题中级篇离散化 区间合并 线段树 中级图论 高级篇 高级数学问题 博弈论 字符串 KMP字符串下标从1开始，next数组从0开始；字符串下标从0开始，next数组从-1开始 12345678910111213141516171819// 待匹配串s，模式串p，下标从1开始int n+1 = s.size();int m+1 = p.size();// 求next数组, next[1] = 0for (int i = 2, j = 0; i &lt;= m; i++) &#123; while(j &amp;&amp; p[i] != p[j+1]) j = ne[j]; if (p[i] == p[j+1]) j++; ne[i] = j;&#125;// kmp匹配for (int i = 1, j = 0; i &lt;= n; i++) &#123; while(j &amp;&amp; s[i] != p[j+1]) j = ne[j]; if (s[i] == p[j+1]) j++; if (j == m) &#123; j = ne[j]; // 匹配成功后的逻辑 &#125;&#125; Trie 树高效存储和查询字符串 时间复杂度$O(\log n)$，时间复杂度$O(n^2)$ 12345678910111213141516171819202122232425const int N = 100010;int son[N][26]; // Trie树每个节点的字节点，此处英文字母只包含26个小写字母int cnt[N];// 以当前这个点结尾的单词数量int idx; // 表示当前使用的层数下标，0号既是空节点也是Trie树的根节点void insert(string str) &#123; int p = 0; for (int i = 0; i &lt; str.size(); i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; &#125; cnt[p] ++;&#125;int query(string str) &#123; int p = 0; for (int i = 0; i &lt; str.size(); i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode二叉树题目总结]]></title>
    <url>%2F2020%2F02%2F01%2Fbinary-tree%2F</url>
    <content type="text"><![CDATA[重建二叉树递归版本 利用哈希数组记录中序遍历中每个值对应的位置 非递归版本 和为某一定值的二叉树路径DFS 树的子结构暴力匹配 找到相同的根节点 同时遍历两颗树 对称二叉树单队列迭代，相邻两个队列成员应该一致 递归 同构二叉树两个队列边遍历边比较 翻转二叉树二叉树的花样遍历加层数 或更改结构体加上int layer;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode链表题目总结]]></title>
    <url>%2F2019%2F03%2F25%2Flinked-list%2F</url>
    <content type="text"><![CDATA[Leetcode链表题常用方法总结： dummy node 常用于链表的head可能被修改或删除的情况，可简化单链表没有前向指针所带来的问题，通常使用current = dummy进行遍历，最终返回 dummy-&gt;next 链表中尽量避免new新的节点，而是在原链表上直接操作地址 在插入和删除操作中使用临时变量来存储next指针 需要反转链表使，通常需要使用pre指针记录前驱节点 通过两个指针几何变换来解决链表长度、环检测等问题 对于一些依赖后面节点才能完成的操作，通常使用递归来解决 常见题目： O(1)时间删除节点删除重复节点删除倒数第k个节点成对反转节点反转链表合并两个有序单链表链表归并排序找两个链表交汇点两个链表同时走a+b+c步 12345678910ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *p = headA, *q = headB; while (p != q) &#123; if (p) p = p-&gt;next; else p = headB; if (q) q = q-&gt;next; else q = headA; &#125; return p;&#125; 链表环的入口两指针一快一满，快指针以两倍速度行走，必定相遇在环内 相遇点单步遍历直至回到相同位置，可得环的长度n 两指针重新从头部以相同速度行走，一指针先走n步，两指针相遇位置即环的入口 复杂链表的复制带random指针的listNode节点的复制 使用哈希表保存random指针的原节点和复制节点对应关系 在原链表上穿叉复制节点]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
</search>
